*** bootasm.S	2018-04-02 22:38:25.890675642 +0800
--- bootasm.S	2018-04-02 22:38:25.886675400 +0800
***************
*** 8,14 ****
  .set PROT_MODE_CSEG,        0x8                     # kernel code segment selector
  .set PROT_MODE_DSEG,        0x10                    # kernel data segment selector
  .set CR0_PE_ON,             0x1                     # protected mode enable flag
- .set SMAP,                  0x534d4150
  
  # start address should be 0:7c00, in real mode, the beginning address of the running bootloader
  .globl start
--- 8,13 ----
  .set PROT_MODE_CSEG,        0x8                     # kernel code segment selector
  .set PROT_MODE_DSEG,        0x10                    # kernel data segment selector
  .set CR0_PE_ON,             0x1                     # protected mode enable flag
  
  # start address should be 0:7c00, in real mode, the beginning address of the running bootloader
  .globl start
***************
*** 43,67 ****
      movb $0xdf, %al                                 # 0xdf -> port 0x60
      outb %al, $0x60                                 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1
  
- probe_memory:
-     movl $0, 0x8000
-     xorl %ebx, %ebx
-     movw $0x8004, %di
- start_probe:
-     movl $0xE820, %eax
-     movl $20, %ecx
-     movl $SMAP, %edx
-     int $0x15
-     jnc cont
-     movw $12345, 0x8000
-     jmp finish_probe
- cont:
-     addw $20, %di
-     incl 0x8000
-     cmpl $0, %ebx
-     jnz start_probe
- finish_probe:
- 
      # Switch from real to protected mode, using a bootstrap GDT
      # and segment translation that makes virtual addresses
      # identical to physical addresses, so that the
--- 42,47 ----
      movb $0xdf, %al                                 # 0xdf -> port 0x60
      outb %al, $0x60                                 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1
  
      # Switch from real to protected mode, using a bootstrap GDT
      # and segment translation that makes virtual addresses
      # identical to physical addresses, so that the
***************
*** 94,100 ****
  spin:
      jmp spin
  
- .data
  # Bootstrap GDT
  .p2align 2                                          # force 4 byte alignment
  gdt:
--- 74,79 ----
  spin:
      jmp spin
  
  # Bootstrap GDT
  .p2align 2                                          # force 4 byte alignment
  gdt:
*** kdebug.c	2018-04-02 22:38:25.890675642 +0800
--- kdebug.c	2018-05-01 18:03:10.257291372 +0800
***************
*** 3,12 ****
  #include <stab.h>
  #include <stdio.h>
  #include <string.h>
- #include <sync.h>
  #include <kdebug.h>
- #include <kmonitor.h>
- #include <assert.h>
  
  #define STACKFRAME_DEPTH 20
  
--- 3,9 ----
  #include <stab.h>
  #include <stdio.h>
  #include <string.h>
  #include <kdebug.h>
  
  #define STACKFRAME_DEPTH 20
  
***************
*** 305,309 ****
        *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]
        *                   the calling funciton's ebp = ss:[ebp]
        */
  }
  
--- 302,321 ----
        *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]
        *                   the calling funciton's ebp = ss:[ebp]
        */
+ 	uint32_t mebp=read_ebp();
+ 	uint32_t meip=read_eip();
+ 	int i;
+ 	for(i=0;i<STACKFRAME_DEPTH;i++){
+ 		cprintf("sf\n");
+ 		cprintf("ebp : %08x , eip: %08x \n",mebp,meip);
+ 		cprintf("calling arguments: %08x  %08x %08x %08x\n",*(uint32_t*)(mebp+2),*(uint32_t*)(mebp+4),*(uint32_t*)(mebp+6),*(uint32_t*)(mebp+8));
+ 		
+ 		print_debuginfo(meip-1);
+ 		meip=((uint32_t *)mebp)[1];
+ 		mebp=((uint32_t *)mebp)[0];
+ 		
+ 		
+ 	}
+ 	
  }
  
*** kdebug.h	2018-04-02 22:38:25.890675642 +0800
--- kdebug.h	2018-04-02 22:38:25.886675400 +0800
***************
*** 2,8 ****
  #define __KERN_DEBUG_KDEBUG_H__
  
  #include <defs.h>
- #include <trap.h>
  
  void print_kerninfo(void);
  void print_stackframe(void);
--- 2,7 ----
  #define __KERN_DEBUG_KDEBUG_H__
  
  #include <defs.h>
  
  void print_kerninfo(void);
  void print_stackframe(void);
*** kmonitor.c	2018-04-02 22:38:25.890675642 +0800
--- kmonitor.c	2018-04-02 22:38:25.886675400 +0800
***************
*** 1,6 ****
  #include <stdio.h>
  #include <string.h>
- #include <mmu.h>
  #include <trap.h>
  #include <kmonitor.h>
  #include <kdebug.h>
--- 1,5 ----
  #include <stdio.h>
  #include <string.h>
  #include <trap.h>
  #include <kmonitor.h>
  #include <kdebug.h>
***************
*** 23,31 ****
      {"backtrace", "Print backtrace of stack frame.", mon_backtrace},
  };
  
- /* return if kernel is panic, in kern/debug/panic.c */
- bool is_kernel_panic(void);
- 
  #define NCOMMANDS (sizeof(commands)/sizeof(struct command))
  
  /***** Kernel monitor command interpreter *****/
--- 22,27 ----
      {"backtrace", "Print backtrace of stack frame.", mon_backtrace},
  };
  
  #define NCOMMANDS (sizeof(commands)/sizeof(struct command))
  
  /***** Kernel monitor command interpreter *****/
*** kmonitor.h	2018-04-02 22:38:25.890675642 +0800
--- kmonitor.h	2018-04-02 22:38:25.886675400 +0800
***************
*** 8,19 ****
  int mon_help(int argc, char **argv, struct trapframe *tf);
  int mon_kerninfo(int argc, char **argv, struct trapframe *tf);
  int mon_backtrace(int argc, char **argv, struct trapframe *tf);
- int mon_continue(int argc, char **argv, struct trapframe *tf);
- int mon_step(int argc, char **argv, struct trapframe *tf);
- int mon_breakpoint(int argc, char **argv, struct trapframe *tf);
- int mon_watchpoint(int argc, char **argv, struct trapframe *tf);
- int mon_delete_dr(int argc, char **argv, struct trapframe *tf);
- int mon_list_dr(int argc, char **argv, struct trapframe *tf);
  
  #endif /* !__KERN_DEBUG_MONITOR_H__ */
  
--- 8,13 ----
  int mon_help(int argc, char **argv, struct trapframe *tf);
  int mon_kerninfo(int argc, char **argv, struct trapframe *tf);
  int mon_backtrace(int argc, char **argv, struct trapframe *tf);
  
  #endif /* !__KERN_DEBUG_MONITOR_H__ */
  
*** console.c	2018-04-02 22:38:25.890675642 +0800
--- console.c	2018-04-02 22:38:25.890675642 +0800
***************
*** 5,12 ****
  #include <kbdreg.h>
  #include <picirq.h>
  #include <trap.h>
- #include <memlayout.h>
- #include <sync.h>
  
  /* stupid I/O delay routine necessitated by historical PC design flaws */
  static void
--- 5,10 ----
  #include <kbdreg.h>
  #include <picirq.h>
  #include <trap.h>
  
  /* stupid I/O delay routine necessitated by historical PC design flaws */
  static void
***************
*** 54,83 ****
  static uint16_t crt_pos;
  static uint16_t addr_6845;
  
  /* TEXT-mode CGA/VGA display output */
- 
  static void
  cga_init(void) {
!     volatile uint16_t *cp = (uint16_t *)(CGA_BUF + KERNBASE);
!     uint16_t was = *cp;
!     *cp = (uint16_t) 0xA55A;
!     if (*cp != 0xA55A) {
!         cp = (uint16_t*)(MONO_BUF + KERNBASE);
!         addr_6845 = MONO_BASE;
!     } else {
!         *cp = was;
!         addr_6845 = CGA_BASE;
      }
  
      // Extract cursor location
      uint32_t pos;
!     outb(addr_6845, 14);
!     pos = inb(addr_6845 + 1) << 8;
      outb(addr_6845, 15);
!     pos |= inb(addr_6845 + 1);
  
!     crt_buf = (uint16_t*) cp;
!     crt_pos = pos;
  }
  
  static bool serial_exists = 0;
--- 52,92 ----
  static uint16_t crt_pos;
  static uint16_t addr_6845;
  
+ // 显示器初始化，CGA 是 Color Graphics Adapter 的缩写
+ // CGA显存按照下面的方式映射：
+ //   -- 0xB0000 - 0xB7777 单色字符模式
+ //   -- 0xB8000 - 0xBFFFF 彩色字符模式及 CGA 兼容图形模式
+ // 6845芯片是IBM PC中的视频控制器
+ // CPU通过IO地址0x3B4-0x3B5来驱动6845控制单色显示，通过IO地址0x3D4-0x3D5来控制彩色显示。
+ //    -- 数据寄存器 映射 到 端口 0x3D5或0x3B5 
+ //    -- 索引寄存器 0x3D4或0x3B4,决定在数据寄存器中的数据表示什么。
+ 
  /* TEXT-mode CGA/VGA display output */
  static void
  cga_init(void) {
!     volatile uint16_t *cp = (uint16_t *)CGA_BUF;   //CGA_BUF: 0xB8000 (彩色显示的显存物理基址)
!     uint16_t was = *cp;                                            //保存当前显存0xB8000处的值
!     *cp = (uint16_t) 0xA55A;                                   // 给这个地址随便写个值，看看能否再读出同样的值
!     if (*cp != 0xA55A) {                                            // 如果读不出来，说明没有这块显存，即是单显配置
!         cp = (uint16_t*)MONO_BUF;                         //设置为单显的显存基址 MONO_BUF： 0xB0000
!         addr_6845 = MONO_BASE;                           //设置为单显控制的IO地址，MONO_BASE: 0x3B4
!     } else {                                                                // 如果读出来了，有这块显存，即是彩显配置
!         *cp = was;                                                      //还原原来显存位置的值
!         addr_6845 = CGA_BASE;                               // 设置为彩显控制的IO地址，CGA_BASE: 0x3D4 
      }
  
      // Extract cursor location
+     // 6845索引寄存器的index 0x0E（及十进制的14）== 光标位置(高位)
+     // 6845索引寄存器的index 0x0F（及十进制的15）== 光标位置(低位)
+     // 6845 reg 15 : Cursor Address (Low Byte)
      uint32_t pos;
!     outb(addr_6845, 14);                                        
!     pos = inb(addr_6845 + 1) << 8;                       //读出了光标位置(高位)
      outb(addr_6845, 15);
!     pos |= inb(addr_6845 + 1);                             //读出了光标位置(低位)
  
!     crt_buf = (uint16_t*) cp;                                  //crt_buf是CGA显存起始地址
!     crt_pos = pos;                                                  //crt_pos是CGA当前光标位置
  }
  
  static bool serial_exists = 0;
***************
*** 425,438 ****
  /* cons_putc - print a single character @c to console devices */
  void
  cons_putc(int c) {
!     bool intr_flag;
!     local_intr_save(intr_flag);
!     {
!         lpt_putc(c);
!         cga_putc(c);
!         serial_putc(c);
!     }
!     local_intr_restore(intr_flag);
  }
  
  /* *
--- 434,442 ----
  /* cons_putc - print a single character @c to console devices */
  void
  cons_putc(int c) {
!     lpt_putc(c);
!     cga_putc(c);
!     serial_putc(c);
  }
  
  /* *
***************
*** 441,465 ****
   * */
  int
  cons_getc(void) {
!     int c = 0;
!     bool intr_flag;
!     local_intr_save(intr_flag);
!     {
!         // poll for any pending input characters,
!         // so that this function works even when interrupts are disabled
!         // (e.g., when called from the kernel monitor).
!         serial_intr();
!         kbd_intr();
! 
!         // grab the next character from the input buffer.
!         if (cons.rpos != cons.wpos) {
!             c = cons.buf[cons.rpos ++];
!             if (cons.rpos == CONSBUFSIZE) {
!                 cons.rpos = 0;
!             }
          }
      }
!     local_intr_restore(intr_flag);
!     return c;
  }
  
--- 445,466 ----
   * */
  int
  cons_getc(void) {
!     int c;
! 
!     // poll for any pending input characters,
!     // so that this function works even when interrupts are disabled
!     // (e.g., when called from the kernel monitor).
!     serial_intr();
!     kbd_intr();
! 
!     // grab the next character from the input buffer.
!     if (cons.rpos != cons.wpos) {
!         c = cons.buf[cons.rpos ++];
!         if (cons.rpos == CONSBUFSIZE) {
!             cons.rpos = 0;
          }
+         return c;
      }
!     return 0;
  }
  
*** init.c	2018-04-02 22:38:25.890675642 +0800
--- init.c	2018-05-02 21:58:55.676145146 +0800
***************
*** 9,15 ****
  #include <intr.h>
  #include <pmm.h>
  #include <kmonitor.h>
- 
  int kern_init(void) __attribute__((noreturn));
  void grade_backtrace(void);
  static void lab1_switch_test(void);
--- 9,14 ----
  #include <intr.h>
  #include <pmm.h>
  #include <kmonitor.h>
  int kern_init(void) __attribute__((noreturn));
  void grade_backtrace(void);
  static void lab1_switch_test(void);
***************
*** 26,32 ****
  
      print_kerninfo();
  
!     grade_backtrace();
  
      pmm_init();                 // init physical memory management
  
--- 25,31 ----
  
      print_kerninfo();
  
! //grade_backtrace();
  
      pmm_init();                 // init physical memory management
  
*** readline.c	2018-04-02 22:38:25.890675642 +0800
--- readline.c	2018-04-02 22:38:25.890675642 +0800
***************
*** 1,11 ****
  #include <stdio.h>
  
! #define BUFSIZE 1024
  static char buf[BUFSIZE];
  
  /* *
   * readline - get a line from stdin
!  * @prompt:     the string to be written to stdout
   *
   * The readline() function will write the input string @prompt to
   * stdout first. If the @prompt is NULL or the empty string,
--- 1,11 ----
  #include <stdio.h>
  
! #define BUFSIZE    1024
  static char buf[BUFSIZE];
  
  /* *
   * readline - get a line from stdin
!  * @prompt:        the string to be written to stdout
   *
   * The readline() function will write the input string @prompt to
   * stdout first. If the @prompt is NULL or the empty string,
*** memlayout.h	2018-04-02 22:38:25.890675642 +0800
--- memlayout.h	2018-04-02 22:38:25.890675642 +0800
***************
*** 4,130 ****
  /* This file contains the definitions for memory management in our OS. */
  
  /* global segment number */
! #define SEG_KTEXT   1
! #define SEG_KDATA   2
! #define SEG_UTEXT   3
! #define SEG_UDATA   4
! #define SEG_TSS     5
! 
! /* global descrptor numbers */
! #define GD_KTEXT    ((SEG_KTEXT) << 3)      // kernel text
! #define GD_KDATA    ((SEG_KDATA) << 3)      // kernel data
! #define GD_UTEXT    ((SEG_UTEXT) << 3)      // user text
! #define GD_UDATA    ((SEG_UDATA) << 3)      // user data
! #define GD_TSS      ((SEG_TSS) << 3)        // task segment selector
  
! #define DPL_KERNEL  (0)
  #define DPL_USER    (3)
  
! #define KERNEL_CS   ((GD_KTEXT) | DPL_KERNEL)
! #define KERNEL_DS   ((GD_KDATA) | DPL_KERNEL)
! #define USER_CS     ((GD_UTEXT) | DPL_USER)
! #define USER_DS     ((GD_UDATA) | DPL_USER)
! 
! /* *
!  * Virtual memory map:                                          Permissions
!  *                                                              kernel/user
!  *
!  *     4G ------------------> +---------------------------------+
!  *                            |                                 |
!  *                            |         Empty Memory (*)        |
!  *                            |                                 |
!  *                            +---------------------------------+ 0xFB000000
!  *                            |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE
!  *     VPT -----------------> +---------------------------------+ 0xFAC00000
!  *                            |        Invalid Memory (*)       | --/--
!  *     KERNTOP -------------> +---------------------------------+ 0xF8000000
!  *                            |                                 |
!  *                            |    Remapped Physical Memory     | RW/-- KMEMSIZE
!  *                            |                                 |
!  *     KERNBASE ------------> +---------------------------------+ 0xC0000000
!  *                            |                                 |
!  *                            |                                 |
!  *                            |                                 |
!  *                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!  * (*) Note: The kernel ensures that "Invalid Memory" is *never* mapped.
!  *     "Empty Memory" is normally unmapped, but user programs may map pages
!  *     there if desired.
!  *
!  * */
! 
! /* All physical memory mapped at this address */
! #define KERNBASE            0xC0000000
! #define KMEMSIZE            0x38000000                  // the maximum amount of physical memory
! #define KERNTOP             (KERNBASE + KMEMSIZE)
! 
! /* *
!  * Virtual page table. Entry PDX[VPT] in the PD (Page Directory) contains
!  * a pointer to the page directory itself, thereby turning the PD into a page
!  * table, which maps all the PTEs (Page Table Entry) containing the page mappings
!  * for the entire virtual address space into that 4 Meg region starting at VPT.
!  * */
! #define VPT                 0xFAC00000
! 
! #define KSTACKPAGE          2                           // # of pages in kernel stack
! #define KSTACKSIZE          (KSTACKPAGE * PGSIZE)       // sizeof kernel stack
! 
! #ifndef __ASSEMBLER__
! 
! #include <defs.h>
! #include <atomic.h>
! #include <list.h>
! 
! typedef uintptr_t pte_t;
! typedef uintptr_t pde_t;
! 
! // some constants for bios interrupt 15h AX = 0xE820
! #define E820MAX             20      // number of entries in E820MAP
! #define E820_ARM            1       // address range memory
! #define E820_ARR            2       // address range reserved
! 
! struct e820map {
!     int nr_map;
!     struct {
!         uint64_t addr;
!         uint64_t size;
!         uint32_t type;
!     } __attribute__((packed)) map[E820MAX];
! };
! 
! /* *
!  * struct Page - Page descriptor structures. Each Page describes one
!  * physical page. In kern/mm/pmm.h, you can find lots of useful functions
!  * that convert Page to other data types, such as phyical address.
!  * */
! struct Page {
!     int ref;                        // page frame's reference counter
!     uint32_t flags;                 // array of flags that describe the status of the page frame
!     unsigned int property;          // the num of free block, used in first fit pm manager
!     list_entry_t page_link;         // free list link
! };
! 
! /* Flags describing the status of a page frame */
! #define PG_reserved                 0       // if this bit=1: the Page is reserved for kernel, cannot be used in alloc/free_pages; otherwise, this bit=0 
! #define PG_property                 1       // if this bit=1: the Page is the head page of a free memory block(contains some continuous_addrress pages), and can be used in alloc_pages; if this bit=0: if the Page is the the head page of a free memory block, then this Page and the memory block is alloced. Or this Page isn't the head page.
! 
! #define SetPageReserved(page)       set_bit(PG_reserved, &((page)->flags))
! #define ClearPageReserved(page)     clear_bit(PG_reserved, &((page)->flags))
! #define PageReserved(page)          test_bit(PG_reserved, &((page)->flags))
! #define SetPageProperty(page)       set_bit(PG_property, &((page)->flags))
! #define ClearPageProperty(page)     clear_bit(PG_property, &((page)->flags))
! #define PageProperty(page)          test_bit(PG_property, &((page)->flags))
! 
! // convert list entry to page
! #define le2page(le, member)                 \
!     to_struct((le), struct Page, member)
! 
! /* free_area_t - maintains a doubly linked list to record free (unused) pages */
! typedef struct {
!     list_entry_t free_list;         // the list header
!     unsigned int nr_free;           // # of free pages in this free list
! } free_area_t;
! 
! #endif /* !__ASSEMBLER__ */
  
  #endif /* !__KERN_MM_MEMLAYOUT_H__ */
  
--- 4,29 ----
  /* This file contains the definitions for memory management in our OS. */
  
  /* global segment number */
! #define SEG_KTEXT    1
! #define SEG_KDATA    2
! #define SEG_UTEXT    3
! #define SEG_UDATA    4
! #define SEG_TSS        5
! 
! /* global descriptor numbers */
! #define GD_KTEXT    ((SEG_KTEXT) << 3)        // kernel text
! #define GD_KDATA    ((SEG_KDATA) << 3)        // kernel data
! #define GD_UTEXT    ((SEG_UTEXT) << 3)        // user text
! #define GD_UDATA    ((SEG_UDATA) << 3)        // user data
! #define GD_TSS        ((SEG_TSS) << 3)        // task segment selector
  
! #define DPL_KERNEL    (0)
  #define DPL_USER    (3)
  
! #define KERNEL_CS    ((GD_KTEXT) | DPL_KERNEL)
! #define KERNEL_DS    ((GD_KDATA) | DPL_KERNEL)
! #define USER_CS        ((GD_UTEXT) | DPL_USER)
! #define USER_DS        ((GD_UDATA) | DPL_USER)
  
  #endif /* !__KERN_MM_MEMLAYOUT_H__ */
  
*** mmu.h	2018-04-02 22:38:25.890675642 +0800
--- mmu.h	2018-05-02 20:30:35.790579617 +0800
***************
*** 2,77 ****
  #define __KERN_MM_MMU_H__
  
  /* Eflags register */
! #define FL_CF           0x00000001  // Carry Flag
! #define FL_PF           0x00000004  // Parity Flag
! #define FL_AF           0x00000010  // Auxiliary carry Flag
! #define FL_ZF           0x00000040  // Zero Flag
! #define FL_SF           0x00000080  // Sign Flag
! #define FL_TF           0x00000100  // Trap Flag
! #define FL_IF           0x00000200  // Interrupt Flag
! #define FL_DF           0x00000400  // Direction Flag
! #define FL_OF           0x00000800  // Overflow Flag
! #define FL_IOPL_MASK    0x00003000  // I/O Privilege Level bitmask
! #define FL_IOPL_0       0x00000000  //   IOPL == 0
! #define FL_IOPL_1       0x00001000  //   IOPL == 1
! #define FL_IOPL_2       0x00002000  //   IOPL == 2
! #define FL_IOPL_3       0x00003000  //   IOPL == 3
! #define FL_NT           0x00004000  // Nested Task
! #define FL_RF           0x00010000  // Resume Flag
! #define FL_VM           0x00020000  // Virtual 8086 mode
! #define FL_AC           0x00040000  // Alignment Check
! #define FL_VIF          0x00080000  // Virtual Interrupt Flag
! #define FL_VIP          0x00100000  // Virtual Interrupt Pending
! #define FL_ID           0x00200000  // ID flag
  
  /* Application segment type bits */
! #define STA_X           0x8         // Executable segment
! #define STA_E           0x4         // Expand down (non-executable segments)
! #define STA_C           0x4         // Conforming code segment (executable only)
! #define STA_W           0x2         // Writeable (non-executable segments)
! #define STA_R           0x2         // Readable (executable segments)
! #define STA_A           0x1         // Accessed
  
  /* System segment type bits */
! #define STS_T16A        0x1         // Available 16-bit TSS
! #define STS_LDT         0x2         // Local Descriptor Table
! #define STS_T16B        0x3         // Busy 16-bit TSS
! #define STS_CG16        0x4         // 16-bit Call Gate
! #define STS_TG          0x5         // Task Gate / Coum Transmitions
! #define STS_IG16        0x6         // 16-bit Interrupt Gate
! #define STS_TG16        0x7         // 16-bit Trap Gate
! #define STS_T32A        0x9         // Available 32-bit TSS
! #define STS_T32B        0xB         // Busy 32-bit TSS
! #define STS_CG32        0xC         // 32-bit Call Gate
! #define STS_IG32        0xE         // 32-bit Interrupt Gate
! #define STS_TG32        0xF         // 32-bit Trap Gate
! 
! #ifdef __ASSEMBLER__
! 
! #define SEG_NULL                                                \
!     .word 0, 0;                                                 \
!     .byte 0, 0, 0, 0
! 
! #define SEG_ASM(type,base,lim)                                  \
!     .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);          \
!     .byte (((base) >> 16) & 0xff), (0x90 | (type)),             \
!         (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
! 
! #else /* not __ASSEMBLER__ */
! 
! #include <defs.h>
  
  /* Gate descriptors for interrupts and traps */
  struct gatedesc {
!     unsigned gd_off_15_0 : 16;      // low 16 bits of offset in segment
      unsigned gd_ss : 16;            // segment selector
!     unsigned gd_args : 5;           // # args, 0 for interrupt/trap gates
!     unsigned gd_rsv1 : 3;           // reserved(should be zero I guess)
!     unsigned gd_type : 4;           // type(STS_{TG,IG32,TG32})
!     unsigned gd_s : 1;              // must be 0 (system)
      unsigned gd_dpl : 2;            // descriptor(meaning new) privilege level
!     unsigned gd_p : 1;              // Present
!     unsigned gd_off_31_16 : 16;     // high bits of offset in segment
  };
  
  /* *
--- 2,62 ----
  #define __KERN_MM_MMU_H__
  
  /* Eflags register */
! #define FL_CF            0x00000001    // Carry Flag
! #define FL_PF            0x00000004    // Parity Flag
! #define FL_AF            0x00000010    // Auxiliary carry Flag
! #define FL_ZF            0x00000040    // Zero Flag
! #define FL_SF            0x00000080    // Sign Flag
! #define FL_TF            0x00000100    // Trap Flag
! #define FL_IF            0x00000200    // Interrupt Flag
! #define FL_DF            0x00000400    // Direction Flag
! #define FL_OF            0x00000800    // Overflow Flag
! #define FL_IOPL_MASK    0x00003000    // I/O Privilege Level bitmask
! #define FL_IOPL_0        0x00000000    //   IOPL == 0
! #define FL_IOPL_1        0x00001000    //   IOPL == 1
! #define FL_IOPL_2        0x00002000    //   IOPL == 2
! #define FL_IOPL_3        0x00003000    //   IOPL == 3
! #define FL_NT            0x00004000    // Nested Task
! #define FL_RF            0x00010000    // Resume Flag
! #define FL_VM            0x00020000    // Virtual 8086 mode
! #define FL_AC            0x00040000    // Alignment Check
! #define FL_VIF            0x00080000    // Virtual Interrupt Flag
! #define FL_VIP            0x00100000    // Virtual Interrupt Pending
! #define FL_ID            0x00200000    // ID flag
  
  /* Application segment type bits */
! #define STA_X            0x8            // Executable segment
! #define STA_E            0x4            // Expand down (non-executable segments)
! #define STA_C            0x4            // Conforming code segment (executable only)
! #define STA_W            0x2            // Writeable (non-executable segments)
! #define STA_R            0x2            // Readable (executable segments)
! #define STA_A            0x1            // Accessed
  
  /* System segment type bits */
! #define STS_T16A        0x1            // Available 16-bit TSS
! #define STS_LDT            0x2            // Local Descriptor Table
! #define STS_T16B        0x3            // Busy 16-bit TSS
! #define STS_CG16        0x4            // 16-bit Call Gate
! #define STS_TG            0x5            // Task Gate / Coum Transmitions
! #define STS_IG16        0x6            // 16-bit Interrupt Gate
! #define STS_TG16        0x7            // 16-bit Trap Gate
! #define STS_T32A        0x9            // Available 32-bit TSS
! #define STS_T32B        0xB            // Busy 32-bit TSS
! #define STS_CG32        0xC            // 32-bit Call Gate
! #define STS_IG32        0xE            // 32-bit Interrupt Gate
! #define STS_TG32        0xF            // 32-bit Trap Gate
  
  /* Gate descriptors for interrupts and traps */
  struct gatedesc {
!     unsigned gd_off_15_0 : 16;        // low 16 bits of offset in segment
      unsigned gd_ss : 16;            // segment selector
!     unsigned gd_args : 5;            // # args, 0 for interrupt/trap gates
!     unsigned gd_rsv1 : 3;            // reserved(should be zero I guess)
!     unsigned gd_type : 4;            // type(STS_{TG,IG32,TG32})
!     unsigned gd_s : 1;                // must be 0 (system)
      unsigned gd_dpl : 2;            // descriptor(meaning new) privilege level
!     unsigned gd_p : 1;                // Present
!     unsigned gd_off_31_16 : 16;        // high bits of offset in segment
  };
  
  /* *
***************
*** 83,153 ****
   *          for software to invoke this interrupt/trap gate explicitly
   *          using an int instruction.
   * */
! #define SETGATE(gate, istrap, sel, off, dpl) {               \
!         (gate).gd_off_15_0 = (uint32_t)(off) & 0xffff;      \
!         (gate).gd_ss = (sel);                                \
!         (gate).gd_args = 0;                                 \
!         (gate).gd_rsv1 = 0;                                 \
!         (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;    \
!         (gate).gd_s = 0;                                    \
!         (gate).gd_dpl = (dpl);                              \
!         (gate).gd_p = 1;                                    \
!         (gate).gd_off_31_16 = (uint32_t)(off) >> 16;        \
!     }
  
  /* Set up a call gate descriptor */
! #define SETCALLGATE(gate, ss, off, dpl) {                   \
!         (gate).gd_off_15_0 = (uint32_t)(off) & 0xffff;      \
!         (gate).gd_ss = (ss);                                \
!         (gate).gd_args = 0;                                 \
!         (gate).gd_rsv1 = 0;                                 \
!         (gate).gd_type = STS_CG32;                          \
!         (gate).gd_s = 0;                                    \
!         (gate).gd_dpl = (dpl);                              \
!         (gate).gd_p = 1;                                    \
!         (gate).gd_off_31_16 = (uint32_t)(off) >> 16;        \
!     }
  
  /* segment descriptors */
  struct segdesc {
!     unsigned sd_lim_15_0 : 16;      // low bits of segment limit
!     unsigned sd_base_15_0 : 16;     // low bits of segment base address
!     unsigned sd_base_23_16 : 8;     // middle bits of segment base address
!     unsigned sd_type : 4;           // segment type (see STS_ constants)
!     unsigned sd_s : 1;              // 0 = system, 1 = application
      unsigned sd_dpl : 2;            // descriptor Privilege Level
!     unsigned sd_p : 1;              // present
!     unsigned sd_lim_19_16 : 4;      // high bits of segment limit
      unsigned sd_avl : 1;            // unused (available for software use)
!     unsigned sd_rsv1 : 1;           // reserved
!     unsigned sd_db : 1;             // 0 = 16-bit segment, 1 = 32-bit segment
!     unsigned sd_g : 1;              // granularity: limit scaled by 4K when set
!     unsigned sd_base_31_24 : 8;     // high bits of segment base address
  };
  
  #define SEG_NULL                                            \
!     (struct segdesc) {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
  
! #define SEG(type, base, lim, dpl)                           \
!     (struct segdesc) {                                      \
!         ((lim) >> 12) & 0xffff, (base) & 0xffff,            \
!         ((base) >> 16) & 0xff, type, 1, dpl, 1,             \
!         (unsigned)(lim) >> 28, 0, 0, 1, 1,                  \
!         (unsigned) (base) >> 24                             \
      }
  
! #define SEGTSS(type, base, lim, dpl)                        \
!     (struct segdesc) {                                      \
!         (lim) & 0xffff, (base) & 0xffff,                    \
!         ((base) >> 16) & 0xff, type, 0, dpl, 1,             \
!         (unsigned) (lim) >> 16, 0, 0, 1, 0,                 \
!         (unsigned) (base) >> 24                             \
      }
  
  /* task state segment format (as described by the Pentium architecture book) */
  struct taskstate {
!     uint32_t ts_link;       // old ts selector
!     uintptr_t ts_esp0;      // stack pointers and segment selectors
      uint16_t ts_ss0;        // after an increase in privilege level
      uint16_t ts_padding1;
      uintptr_t ts_esp1;
--- 68,138 ----
   *          for software to invoke this interrupt/trap gate explicitly
   *          using an int instruction.
   * */
! #define SETGATE(gate, istrap, sel, off, dpl) {            \
!     (gate).gd_off_15_0 = (uint32_t)(off) & 0xffff;        \
!     (gate).gd_ss = (sel);                                \
!     (gate).gd_args = 0;                                    \
!     (gate).gd_rsv1 = 0;                                    \
!     (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;    \
!     (gate).gd_s = 0;                                    \
!     (gate).gd_dpl = (dpl);                                \
!     (gate).gd_p = 1;                                    \
!     (gate).gd_off_31_16 = (uint32_t)(off) >> 16;        \
! }
  
  /* Set up a call gate descriptor */
! #define SETCALLGATE(gate, ss, off, dpl) {                \
!     (gate).gd_off_15_0 = (uint32_t)(off) & 0xffff;        \
!     (gate).gd_ss = (ss);                                \
!     (gate).gd_args = 0;                                    \
!     (gate).gd_rsv1 = 0;                                    \
!     (gate).gd_type = STS_CG32;                            \
!     (gate).gd_s = 0;                                    \
!     (gate).gd_dpl = (dpl);                                \
!     (gate).gd_p = 1;                                    \
!     (gate).gd_off_31_16 = (uint32_t)(off) >> 16;        \
! }
  
  /* segment descriptors */
  struct segdesc {
!     unsigned sd_lim_15_0 : 16;        // low bits of segment limit
!     unsigned sd_base_15_0 : 16;        // low bits of segment base address
!     unsigned sd_base_23_16 : 8;        // middle bits of segment base address
!     unsigned sd_type : 4;            // segment type (see STS_ constants)
!     unsigned sd_s : 1;                // 0 = system, 1 = application
      unsigned sd_dpl : 2;            // descriptor Privilege Level
!     unsigned sd_p : 1;                // present
!     unsigned sd_lim_19_16 : 4;        // high bits of segment limit
      unsigned sd_avl : 1;            // unused (available for software use)
!     unsigned sd_rsv1 : 1;            // reserved
!     unsigned sd_db : 1;                // 0 = 16-bit segment, 1 = 32-bit segment
!     unsigned sd_g : 1;                // granularity: limit scaled by 4K when set
!     unsigned sd_base_31_24 : 8;        // high bits of segment base address
  };
  
  #define SEG_NULL                                            \
!     (struct segdesc){0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
  
! #define SEG(type, base, lim, dpl)                        \
!     (struct segdesc){                                    \
!         ((lim) >> 12) & 0xffff, (base) & 0xffff,        \
!         ((base) >> 16) & 0xff, type, 1, dpl, 1,            \
!         (unsigned)(lim) >> 28, 0, 0, 1, 1,                \
!         (unsigned) (base) >> 24                            \
      }
  
! #define SEG16(type, base, lim, dpl)                        \
!     (struct segdesc){                                    \
!         (lim) & 0xffff, (base) & 0xffff,                \
!         ((base) >> 16) & 0xff, type, 1, dpl, 1,            \
!         (unsigned) (lim) >> 16, 0, 0, 1, 0,                \
!         (unsigned) (base) >> 24                            \
      }
  
  /* task state segment format (as described by the Pentium architecture book) */
  struct taskstate {
!     uint32_t ts_link;        // old ts selector
!     uintptr_t ts_esp0;        // stack pointers and segment selectors
      uint16_t ts_ss0;        // after an increase in privilege level
      uint16_t ts_padding1;
      uintptr_t ts_esp1;
***************
*** 156,163 ****
      uintptr_t ts_esp2;
      uint16_t ts_ss2;
      uint16_t ts_padding3;
!     uintptr_t ts_cr3;       // page directory base
!     uintptr_t ts_eip;       // saved state from last task switch
      uint32_t ts_eflags;
      uint32_t ts_eax;        // more saved state (registers)
      uint32_t ts_ecx;
--- 141,148 ----
      uintptr_t ts_esp2;
      uint16_t ts_ss2;
      uint16_t ts_padding3;
!     uintptr_t ts_cr3;        // page directory base
!     uintptr_t ts_eip;        // saved state from last task switch
      uint32_t ts_eflags;
      uint32_t ts_eax;        // more saved state (registers)
      uint32_t ts_ecx;
***************
*** 167,173 ****
      uintptr_t ts_ebp;
      uint32_t ts_esi;
      uint32_t ts_edi;
!     uint16_t ts_es;         // even more saved state (segment selectors)
      uint16_t ts_padding4;
      uint16_t ts_cs;
      uint16_t ts_padding5;
--- 152,158 ----
      uintptr_t ts_ebp;
      uint32_t ts_esi;
      uint32_t ts_edi;
!     uint16_t ts_es;            // even more saved state (segment selectors)
      uint16_t ts_padding4;
      uint16_t ts_cs;
      uint16_t ts_padding5;
***************
*** 181,272 ****
      uint16_t ts_padding9;
      uint16_t ts_ldt;
      uint16_t ts_padding10;
!     uint16_t ts_t;          // trap on task switch
!     uint16_t ts_iomb;       // i/o map base address
! } __attribute__((packed));
! 
! #endif /* !__ASSEMBLER__ */
! 
! // A linear address 'la' has a three-part structure as follows:
! //
! // +--------10------+-------10-------+---------12----------+
! // | Page Directory |   Page Table   | Offset within Page  |
! // |      Index     |     Index      |                     |
! // +----------------+----------------+---------------------+
! //  \--- PDX(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/
! //  \----------- PPN(la) -----------/
! //
! // The PDX, PTX, PGOFF, and PPN macros decompose linear addresses as shown.
! // To construct a linear address la from PDX(la), PTX(la), and PGOFF(la),
! // use PGADDR(PDX(la), PTX(la), PGOFF(la)).
! 
! // page directory index
! #define PDX(la) ((((uintptr_t)(la)) >> PDXSHIFT) & 0x3FF)
! 
! // page table index
! #define PTX(la) ((((uintptr_t)(la)) >> PTXSHIFT) & 0x3FF)
! 
! // page number field of address
! #define PPN(la) (((uintptr_t)(la)) >> PTXSHIFT)
! 
! // offset in page
! #define PGOFF(la) (((uintptr_t)(la)) & 0xFFF)
! 
! // construct linear address from indexes and offset
! #define PGADDR(d, t, o) ((uintptr_t)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
! 
! // address in page table or page directory entry
! #define PTE_ADDR(pte)   ((uintptr_t)(pte) & ~0xFFF)
! #define PDE_ADDR(pde)   PTE_ADDR(pde)
! 
! /* page directory and page table constants */
! #define NPDEENTRY       1024                    // page directory entries per page directory
! #define NPTEENTRY       1024                    // page table entries per page table
! 
! #define PGSIZE          4096                    // bytes mapped by a page
! #define PGSHIFT         12                      // log2(PGSIZE)
! #define PTSIZE          (PGSIZE * NPTEENTRY)    // bytes mapped by a page directory entry
! #define PTSHIFT         22                      // log2(PTSIZE)
! 
! #define PTXSHIFT        12                      // offset of PTX in a linear address
! #define PDXSHIFT        22                      // offset of PDX in a linear address
! 
! /* page table/directory entry flags */
! #define PTE_P           0x001                   // Present
! #define PTE_W           0x002                   // Writeable
! #define PTE_U           0x004                   // User
! #define PTE_PWT         0x008                   // Write-Through
! #define PTE_PCD         0x010                   // Cache-Disable
! #define PTE_A           0x020                   // Accessed
! #define PTE_D           0x040                   // Dirty
! #define PTE_PS          0x080                   // Page Size
! #define PTE_MBZ         0x180                   // Bits must be zero
! #define PTE_AVAIL       0xE00                   // Available for software use
!                                                 // The PTE_AVAIL bits aren't used by the kernel or interpreted by the
!                                                 // hardware, so user processes are allowed to set them arbitrarily.
! 
! #define PTE_USER        (PTE_U | PTE_W | PTE_P)
! 
! /* Control Register flags */
! #define CR0_PE          0x00000001              // Protection Enable
! #define CR0_MP          0x00000002              // Monitor coProcessor
! #define CR0_EM          0x00000004              // Emulation
! #define CR0_TS          0x00000008              // Task Switched
! #define CR0_ET          0x00000010              // Extension Type
! #define CR0_NE          0x00000020              // Numeric Errror
! #define CR0_WP          0x00010000              // Write Protect
! #define CR0_AM          0x00040000              // Alignment Mask
! #define CR0_NW          0x20000000              // Not Writethrough
! #define CR0_CD          0x40000000              // Cache Disable
! #define CR0_PG          0x80000000              // Paging
! 
! #define CR4_PCE         0x00000100              // Performance counter enable
! #define CR4_MCE         0x00000040              // Machine Check Enable
! #define CR4_PSE         0x00000010              // Page Size Extensions
! #define CR4_DE          0x00000008              // Debugging Extensions
! #define CR4_TSD         0x00000004              // Time Stamp Disable
! #define CR4_PVI         0x00000002              // Protected-Mode Virtual Interrupts
! #define CR4_VME         0x00000001              // V86 Mode Extensions
  
  #endif /* !__KERN_MM_MMU_H__ */
  
--- 166,174 ----
      uint16_t ts_padding9;
      uint16_t ts_ldt;
      uint16_t ts_padding10;
!     uint16_t ts_t;            // trap on task switch
!     uint16_t ts_iomb;        // i/o map base address
! };
  
  #endif /* !__KERN_MM_MMU_H__ */
  
*** pmm.c	2018-04-02 22:38:25.894675883 +0800
--- pmm.c	2018-04-02 22:38:25.890675642 +0800
***************
*** 1,13 ****
  #include <defs.h>
  #include <x86.h>
- #include <stdio.h>
- #include <string.h>
  #include <mmu.h>
  #include <memlayout.h>
  #include <pmm.h>
- #include <default_pmm.h>
- #include <sync.h>
- #include <error.h>
  
  /* *
   * Task State Segment:
--- 1,8 ----
  #include <defs.h>
  #include <x86.h>
  #include <mmu.h>
  #include <memlayout.h>
  #include <pmm.h>
  
  /* *
   * Task State Segment:
***************
*** 31,66 ****
   * */
  static struct taskstate ts = {0};
  
- // virtual address of physicall page array
- struct Page *pages;
- // amount of physical memory (in pages)
- size_t npage = 0;
- 
- // virtual address of boot-time page directory
- extern pde_t __boot_pgdir;
- pde_t *boot_pgdir = &__boot_pgdir;
- // physical address of boot-time page directory
- uintptr_t boot_cr3;
- 
- // physical memory management
- const struct pmm_manager *pmm_manager;
- 
- /* *
-  * The page directory entry corresponding to the virtual address range
-  * [VPT, VPT + PTSIZE) points to the page directory itself. Thus, the page
-  * directory is treated as a page table as well as a page directory.
-  *
-  * One result of treating the page directory as a page table is that all PTEs
-  * can be accessed though a "virtual page table" at virtual address VPT. And the
-  * PTE for number n is stored in vpt[n].
-  *
-  * A second consequence is that the contents of the current page directory will
-  * always available at virtual address PGADDR(PDX(VPT), PDX(VPT), 0), to which
-  * vpd is set bellow.
-  * */
- pte_t * const vpt = (pte_t *)VPT;
- pde_t * const vpd = (pde_t *)PGADDR(PDX(VPT), PDX(VPT), 0);
- 
  /* *
   * Global Descriptor Table:
   *
--- 26,31 ----
   * */
  static struct taskstate ts = {0};
  
  /* *
   * Global Descriptor Table:
   *
***************
*** 80,96 ****
      [SEG_KDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_KERNEL),
      [SEG_UTEXT] = SEG(STA_X | STA_R, 0x0, 0xFFFFFFFF, DPL_USER),
      [SEG_UDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_USER),
!     [SEG_TSS]   = SEG_NULL,
  };
  
  static struct pseudodesc gdt_pd = {
!     sizeof(gdt) - 1, (uintptr_t)gdt
  };
  
- static void check_alloc_page(void);
- static void check_pgdir(void);
- static void check_boot_pgdir(void);
- 
  /* *
   * lgdt - load the global descriptor table register and reset the
   * data/code segement registers for kernel.
--- 45,57 ----
      [SEG_KDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_KERNEL),
      [SEG_UTEXT] = SEG(STA_X | STA_R, 0x0, 0xFFFFFFFF, DPL_USER),
      [SEG_UDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_USER),
!     [SEG_TSS]    = SEG_NULL,
  };
  
  static struct pseudodesc gdt_pd = {
!     sizeof(gdt) - 1, (uint32_t)gdt
  };
  
  /* *
   * lgdt - load the global descriptor table register and reset the
   * data/code segement registers for kernel.
***************
*** 107,131 ****
      asm volatile ("ljmp %0, $1f\n 1:\n" :: "i" (KERNEL_CS));
  }
  
! /* *
!  * load_esp0 - change the ESP0 in default task state segment,
!  * so that we can use different kernel stack when we trap frame
!  * user to kernel.
!  * */
! void
! load_esp0(uintptr_t esp0) {
!     ts.ts_esp0 = esp0;
! }
  
  /* gdt_init - initialize the default GDT and TSS */
  static void
  gdt_init(void) {
!     // set boot kernel stack and default SS0
!     load_esp0((uintptr_t)bootstacktop);
      ts.ts_ss0 = KERNEL_DS;
  
      // initialize the TSS filed of the gdt
!     gdt[SEG_TSS] = SEGTSS(STS_T32A, (uintptr_t)&ts, sizeof(ts), DPL_KERNEL);
  
      // reload all segment registers
      lgdt(&gdt_pd);
--- 68,88 ----
      asm volatile ("ljmp %0, $1f\n 1:\n" :: "i" (KERNEL_CS));
  }
  
! /* temporary kernel stack */
! uint8_t stack0[1024];
  
  /* gdt_init - initialize the default GDT and TSS */
  static void
  gdt_init(void) {
!     // Setup a TSS so that we can get the right stack when we trap from
!     // user to the kernel. But not safe here, it's only a temporary value,
!     // it will be set to KSTACKTOP in lab2.
!     ts.ts_esp0 = (uint32_t)&stack0 + sizeof(stack0);
      ts.ts_ss0 = KERNEL_DS;
  
      // initialize the TSS filed of the gdt
!     gdt[SEG_TSS] = SEG16(STS_T32A, (uint32_t)&ts, sizeof(ts), DPL_KERNEL);
!     gdt[SEG_TSS].sd_s = 0;
  
      // reload all segment registers
      lgdt(&gdt_pd);
***************
*** 134,606 ****
      ltr(GD_TSS);
  }
  
- //init_pmm_manager - initialize a pmm_manager instance
- static void
- init_pmm_manager(void) {
-     pmm_manager = &default_pmm_manager;
-     cprintf("memory management: %s\n", pmm_manager->name);
-     pmm_manager->init();
- }
- 
- //init_memmap - call pmm->init_memmap to build Page struct for free memory  
- static void
- init_memmap(struct Page *base, size_t n) {
-     pmm_manager->init_memmap(base, n);
- }
- 
- //alloc_pages - call pmm->alloc_pages to allocate a continuous n*PAGESIZE memory 
- struct Page *
- alloc_pages(size_t n) {
-     struct Page *page=NULL;
-     bool intr_flag;
-     local_intr_save(intr_flag);
-     {
-         page = pmm_manager->alloc_pages(n);
-     }
-     local_intr_restore(intr_flag);
-     return page;
- }
- 
- //free_pages - call pmm->free_pages to free a continuous n*PAGESIZE memory 
- void
- free_pages(struct Page *base, size_t n) {
-     bool intr_flag;
-     local_intr_save(intr_flag);
-     {
-         pmm_manager->free_pages(base, n);
-     }
-     local_intr_restore(intr_flag);
- }
- 
- //nr_free_pages - call pmm->nr_free_pages to get the size (nr*PAGESIZE) 
- //of current free memory
- size_t
- nr_free_pages(void) {
-     size_t ret;
-     bool intr_flag;
-     local_intr_save(intr_flag);
-     {
-         ret = pmm_manager->nr_free_pages();
-     }
-     local_intr_restore(intr_flag);
-     return ret;
- }
- 
  /* pmm_init - initialize the physical memory management */
- static void
- page_init(void) {
-     struct e820map *memmap = (struct e820map *)(0x8000 + KERNBASE);
-     uint64_t maxpa = 0;
- 
-     cprintf("e820map:\n");
-     int i;
-     for (i = 0; i < memmap->nr_map; i ++) {
-         uint64_t begin = memmap->map[i].addr, end = begin + memmap->map[i].size;
-         cprintf("  memory: %08llx, [%08llx, %08llx], type = %d.\n",
-                 memmap->map[i].size, begin, end - 1, memmap->map[i].type);
-         if (memmap->map[i].type == E820_ARM) {
-             if (maxpa < end && begin < KMEMSIZE) {
-                 maxpa = end;
-             }
-         }
-     }
-     if (maxpa > KMEMSIZE) {
-         maxpa = KMEMSIZE;
-     }
- 
-     extern char end[];
- 
-     npage = maxpa / PGSIZE;
-     pages = (struct Page *)ROUNDUP((void *)end, PGSIZE);
- 
-     for (i = 0; i < npage; i ++) {
-         SetPageReserved(pages + i);
-     }
- 
-     uintptr_t freemem = PADDR((uintptr_t)pages + sizeof(struct Page) * npage);
- 
-     for (i = 0; i < memmap->nr_map; i ++) {
-         uint64_t begin = memmap->map[i].addr, end = begin + memmap->map[i].size;
-         if (memmap->map[i].type == E820_ARM) {
-             if (begin < freemem) {
-                 begin = freemem;
-             }
-             if (end > KMEMSIZE) {
-                 end = KMEMSIZE;
-             }
-             if (begin < end) {
-                 begin = ROUNDUP(begin, PGSIZE);
-                 end = ROUNDDOWN(end, PGSIZE);
-                 if (begin < end) {
-                     init_memmap(pa2page(begin), (end - begin) / PGSIZE);
-                 }
-             }
-         }
-     }
- }
- 
- //boot_map_segment - setup&enable the paging mechanism
- // parameters
- //  la:   linear address of this memory need to map (after x86 segment map)
- //  size: memory size
- //  pa:   physical address of this memory
- //  perm: permission of this memory  
- static void
- boot_map_segment(pde_t *pgdir, uintptr_t la, size_t size, uintptr_t pa, uint32_t perm) {
-     assert(PGOFF(la) == PGOFF(pa));
-     size_t n = ROUNDUP(size + PGOFF(la), PGSIZE) / PGSIZE;
-     la = ROUNDDOWN(la, PGSIZE);
-     pa = ROUNDDOWN(pa, PGSIZE);
-     for (; n > 0; n --, la += PGSIZE, pa += PGSIZE) {
-         pte_t *ptep = get_pte(pgdir, la, 1);
-         assert(ptep != NULL);
-         *ptep = pa | PTE_P | perm;
-     }
- }
- 
- //boot_alloc_page - allocate one page using pmm->alloc_pages(1) 
- // return value: the kernel virtual address of this allocated page
- //note: this function is used to get the memory for PDT(Page Directory Table)&PT(Page Table)
- static void *
- boot_alloc_page(void) {
-     struct Page *p = alloc_page();
-     if (p == NULL) {
-         panic("boot_alloc_page failed.\n");
-     }
-     return page2kva(p);
- }
- 
- //pmm_init - setup a pmm to manage physical memory, build PDT&PT to setup paging mechanism 
- //         - check the correctness of pmm & paging mechanism, print PDT&PT
  void
  pmm_init(void) {
-     // We've already enabled paging
-     boot_cr3 = PADDR(boot_pgdir);
- 
-     //We need to alloc/free the physical memory (granularity is 4KB or other size). 
-     //So a framework of physical memory manager (struct pmm_manager)is defined in pmm.h
-     //First we should init a physical memory manager(pmm) based on the framework.
-     //Then pmm can alloc/free the physical memory. 
-     //Now the first_fit/best_fit/worst_fit/buddy_system pmm are available.
-     init_pmm_manager();
- 
-     // detect physical memory space, reserve already used memory,
-     // then use pmm->init_memmap to create free page list
-     page_init();
- 
-     //use pmm->check to verify the correctness of the alloc/free function in a pmm
-     check_alloc_page();
- 
-     check_pgdir();
- 
-     static_assert(KERNBASE % PTSIZE == 0 && KERNTOP % PTSIZE == 0);
- 
-     // recursively insert boot_pgdir in itself
-     // to form a virtual page table at virtual address VPT
-     boot_pgdir[PDX(VPT)] = PADDR(boot_pgdir) | PTE_P | PTE_W;
- 
-     // map all physical memory to linear memory with base linear addr KERNBASE
-     // linear_addr KERNBASE ~ KERNBASE + KMEMSIZE = phy_addr 0 ~ KMEMSIZE
-     boot_map_segment(boot_pgdir, KERNBASE, KMEMSIZE, 0, PTE_W);
- 
-     // Since we are using bootloader's GDT,
-     // we should reload gdt (second time, the last time) to get user segments and the TSS
-     // map virtual_addr 0 ~ 4G = linear_addr 0 ~ 4G
-     // then set kernel stack (ss:esp) in TSS, setup TSS in gdt, load TSS
      gdt_init();
- 
-     //now the basic virtual memory map(see memalyout.h) is established.
-     //check the correctness of the basic virtual memory map.
-     check_boot_pgdir();
- 
-     print_pgdir();
- 
- }
- 
- //get_pte - get pte and return the kernel virtual address of this pte for la
- //        - if the PT contians this pte didn't exist, alloc a page for PT
- // parameter:
- //  pgdir:  the kernel virtual base address of PDT
- //  la:     the linear address need to map
- //  create: a logical value to decide if alloc a page for PT
- // return vaule: the kernel virtual address of this pte
- pte_t *
- get_pte(pde_t *pgdir, uintptr_t la, bool create) {
-     /* LAB2 EXERCISE 2: YOUR CODE
-      *
-      * If you need to visit a physical address, please use KADDR()
-      * please read pmm.h for useful macros
-      *
-      * Maybe you want help comment, BELOW comments can help you finish the code
-      *
-      * Some Useful MACROs and DEFINEs, you can use them in below implementation.
-      * MACROs or Functions:
-      *   PDX(la) = the index of page directory entry of VIRTUAL ADDRESS la.
-      *   KADDR(pa) : takes a physical address and returns the corresponding kernel virtual address.
-      *   set_page_ref(page,1) : means the page be referenced by one time
-      *   page2pa(page): get the physical address of memory which this (struct Page *) page  manages
-      *   struct Page * alloc_page() : allocation a page
-      *   memset(void *s, char c, size_t n) : sets the first n bytes of the memory area pointed by s
-      *                                       to the specified value c.
-      * DEFINEs:
-      *   PTE_P           0x001                   // page table/directory entry flags bit : Present
-      *   PTE_W           0x002                   // page table/directory entry flags bit : Writeable
-      *   PTE_U           0x004                   // page table/directory entry flags bit : User can access
-      */
- #if 0
-     pde_t *pdep = NULL;   // (1) find page directory entry
-     if (0) {              // (2) check if entry is not present
-                           // (3) check if creating is needed, then alloc page for page table
-                           // CAUTION: this page is used for page table, not for common data page
-                           // (4) set page reference
-         uintptr_t pa = 0; // (5) get linear address of page
-                           // (6) clear page content using memset
-                           // (7) set page directory entry's permission
-     }
-     return NULL;          // (8) return page table entry
- #endif
- }
- 
- //get_page - get related Page struct for linear address la using PDT pgdir
- struct Page *
- get_page(pde_t *pgdir, uintptr_t la, pte_t **ptep_store) {
-     pte_t *ptep = get_pte(pgdir, la, 0);
-     if (ptep_store != NULL) {
-         *ptep_store = ptep;
-     }
-     if (ptep != NULL && *ptep & PTE_P) {
-         return pte2page(*ptep);
-     }
-     return NULL;
- }
- 
- //page_remove_pte - free an Page sturct which is related linear address la
- //                - and clean(invalidate) pte which is related linear address la
- //note: PT is changed, so the TLB need to be invalidate 
- static inline void
- page_remove_pte(pde_t *pgdir, uintptr_t la, pte_t *ptep) {
-     /* LAB2 EXERCISE 3: YOUR CODE
-      *
-      * Please check if ptep is valid, and tlb must be manually updated if mapping is updated
-      *
-      * Maybe you want help comment, BELOW comments can help you finish the code
-      *
-      * Some Useful MACROs and DEFINEs, you can use them in below implementation.
-      * MACROs or Functions:
-      *   struct Page *page pte2page(*ptep): get the according page from the value of a ptep
-      *   free_page : free a page
-      *   page_ref_dec(page) : decrease page->ref. NOTICE: ff page->ref == 0 , then this page should be free.
-      *   tlb_invalidate(pde_t *pgdir, uintptr_t la) : Invalidate a TLB entry, but only if the page tables being
-      *                        edited are the ones currently in use by the processor.
-      * DEFINEs:
-      *   PTE_P           0x001                   // page table/directory entry flags bit : Present
-      */
- #if 0
-     if (0) {                      //(1) check if this page table entry is present
-         struct Page *page = NULL; //(2) find corresponding page to pte
-                                   //(3) decrease page reference
-                                   //(4) and free this page when page reference reachs 0
-                                   //(5) clear second page table entry
-                                   //(6) flush tlb
-     }
- #endif
- }
- 
- //page_remove - free an Page which is related linear address la and has an validated pte
- void
- page_remove(pde_t *pgdir, uintptr_t la) {
-     pte_t *ptep = get_pte(pgdir, la, 0);
-     if (ptep != NULL) {
-         page_remove_pte(pgdir, la, ptep);
-     }
- }
- 
- //page_insert - build the map of phy addr of an Page with the linear addr la
- // paramemters:
- //  pgdir: the kernel virtual base address of PDT
- //  page:  the Page which need to map
- //  la:    the linear address need to map
- //  perm:  the permission of this Page which is setted in related pte
- // return value: always 0
- //note: PT is changed, so the TLB need to be invalidate 
- int
- page_insert(pde_t *pgdir, struct Page *page, uintptr_t la, uint32_t perm) {
-     pte_t *ptep = get_pte(pgdir, la, 1);
-     if (ptep == NULL) {
-         return -E_NO_MEM;
-     }
-     page_ref_inc(page);
-     if (*ptep & PTE_P) {
-         struct Page *p = pte2page(*ptep);
-         if (p == page) {
-             page_ref_dec(page);
-         }
-         else {
-             page_remove_pte(pgdir, la, ptep);
-         }
-     }
-     *ptep = page2pa(page) | PTE_P | perm;
-     tlb_invalidate(pgdir, la);
-     return 0;
- }
- 
- // invalidate a TLB entry, but only if the page tables being
- // edited are the ones currently in use by the processor.
- void
- tlb_invalidate(pde_t *pgdir, uintptr_t la) {
-     if (rcr3() == PADDR(pgdir)) {
-         invlpg((void *)la);
-     }
- }
- 
- static void
- check_alloc_page(void) {
-     pmm_manager->check();
-     cprintf("check_alloc_page() succeeded!\n");
- }
- 
- static void
- check_pgdir(void) {
-     assert(npage <= KMEMSIZE / PGSIZE);
-     assert(boot_pgdir != NULL && (uint32_t)PGOFF(boot_pgdir) == 0);
-     assert(get_page(boot_pgdir, 0x0, NULL) == NULL);
- 
-     struct Page *p1, *p2;
-     p1 = alloc_page();
-     assert(page_insert(boot_pgdir, p1, 0x0, 0) == 0);
- 
-     pte_t *ptep;
-     assert((ptep = get_pte(boot_pgdir, 0x0, 0)) != NULL);
-     assert(pte2page(*ptep) == p1);
-     assert(page_ref(p1) == 1);
- 
-     ptep = &((pte_t *)KADDR(PDE_ADDR(boot_pgdir[0])))[1];
-     assert(get_pte(boot_pgdir, PGSIZE, 0) == ptep);
- 
-     p2 = alloc_page();
-     assert(page_insert(boot_pgdir, p2, PGSIZE, PTE_U | PTE_W) == 0);
-     assert((ptep = get_pte(boot_pgdir, PGSIZE, 0)) != NULL);
-     assert(*ptep & PTE_U);
-     assert(*ptep & PTE_W);
-     assert(boot_pgdir[0] & PTE_U);
-     assert(page_ref(p2) == 1);
- 
-     assert(page_insert(boot_pgdir, p1, PGSIZE, 0) == 0);
-     assert(page_ref(p1) == 2);
-     assert(page_ref(p2) == 0);
-     assert((ptep = get_pte(boot_pgdir, PGSIZE, 0)) != NULL);
-     assert(pte2page(*ptep) == p1);
-     assert((*ptep & PTE_U) == 0);
- 
-     page_remove(boot_pgdir, 0x0);
-     assert(page_ref(p1) == 1);
-     assert(page_ref(p2) == 0);
- 
-     page_remove(boot_pgdir, PGSIZE);
-     assert(page_ref(p1) == 0);
-     assert(page_ref(p2) == 0);
- 
-     assert(page_ref(pde2page(boot_pgdir[0])) == 1);
-     free_page(pde2page(boot_pgdir[0]));
-     boot_pgdir[0] = 0;
- 
-     cprintf("check_pgdir() succeeded!\n");
- }
- 
- static void
- check_boot_pgdir(void) {
-     pte_t *ptep;
-     int i;
-     for (i = 0; i < npage; i += PGSIZE) {
-         assert((ptep = get_pte(boot_pgdir, (uintptr_t)KADDR(i), 0)) != NULL);
-         assert(PTE_ADDR(*ptep) == i);
-     }
- 
-     assert(PDE_ADDR(boot_pgdir[PDX(VPT)]) == PADDR(boot_pgdir));
- 
-     assert(boot_pgdir[0] == 0);
- 
-     struct Page *p;
-     p = alloc_page();
-     assert(page_insert(boot_pgdir, p, 0x100, PTE_W) == 0);
-     assert(page_ref(p) == 1);
-     assert(page_insert(boot_pgdir, p, 0x100 + PGSIZE, PTE_W) == 0);
-     assert(page_ref(p) == 2);
- 
-     const char *str = "ucore: Hello world!!";
-     strcpy((void *)0x100, str);
-     assert(strcmp((void *)0x100, (void *)(0x100 + PGSIZE)) == 0);
- 
-     *(char *)(page2kva(p) + 0x100) = '\0';
-     assert(strlen((const char *)0x100) == 0);
- 
-     free_page(p);
-     free_page(pde2page(boot_pgdir[0]));
-     boot_pgdir[0] = 0;
- 
-     cprintf("check_boot_pgdir() succeeded!\n");
- }
- 
- //perm2str - use string 'u,r,w,-' to present the permission
- static const char *
- perm2str(int perm) {
-     static char str[4];
-     str[0] = (perm & PTE_U) ? 'u' : '-';
-     str[1] = 'r';
-     str[2] = (perm & PTE_W) ? 'w' : '-';
-     str[3] = '\0';
-     return str;
- }
- 
- //get_pgtable_items - In [left, right] range of PDT or PT, find a continuous linear addr space
- //                  - (left_store*X_SIZE~right_store*X_SIZE) for PDT or PT
- //                  - X_SIZE=PTSIZE=4M, if PDT; X_SIZE=PGSIZE=4K, if PT
- // paramemters:
- //  left:        no use ???
- //  right:       the high side of table's range
- //  start:       the low side of table's range
- //  table:       the beginning addr of table
- //  left_store:  the pointer of the high side of table's next range
- //  right_store: the pointer of the low side of table's next range
- // return value: 0 - not a invalid item range, perm - a valid item range with perm permission 
- static int
- get_pgtable_items(size_t left, size_t right, size_t start, uintptr_t *table, size_t *left_store, size_t *right_store) {
-     if (start >= right) {
-         return 0;
-     }
-     while (start < right && !(table[start] & PTE_P)) {
-         start ++;
-     }
-     if (start < right) {
-         if (left_store != NULL) {
-             *left_store = start;
-         }
-         int perm = (table[start ++] & PTE_USER);
-         while (start < right && (table[start] & PTE_USER) == perm) {
-             start ++;
-         }
-         if (right_store != NULL) {
-             *right_store = start;
-         }
-         return perm;
-     }
-     return 0;
- }
- 
- //print_pgdir - print the PDT&PT
- void
- print_pgdir(void) {
-     cprintf("-------------------- BEGIN --------------------\n");
-     size_t left, right = 0, perm;
-     while ((perm = get_pgtable_items(0, NPDEENTRY, right, vpd, &left, &right)) != 0) {
-         cprintf("PDE(%03x) %08x-%08x %08x %s\n", right - left,
-                 left * PTSIZE, right * PTSIZE, (right - left) * PTSIZE, perm2str(perm));
-         size_t l, r = left * NPTEENTRY;
-         while ((perm = get_pgtable_items(left * NPTEENTRY, right * NPTEENTRY, r, vpt, &l, &r)) != 0) {
-             cprintf("  |-- PTE(%05x) %08x-%08x %08x %s\n", r - l,
-                     l * PGSIZE, r * PGSIZE, (r - l) * PGSIZE, perm2str(perm));
-         }
-     }
-     cprintf("--------------------- END ---------------------\n");
  }
  
--- 91,99 ----
      ltr(GD_TSS);
  }
  
  /* pmm_init - initialize the physical memory management */
  void
  pmm_init(void) {
      gdt_init();
  }
  
*** pmm.h	2018-04-02 22:38:25.894675883 +0800
--- pmm.h	2018-04-02 22:38:25.890675642 +0800
***************
*** 1,143 ****
  #ifndef __KERN_MM_PMM_H__
  #define __KERN_MM_PMM_H__
  
- #include <defs.h>
- #include <mmu.h>
- #include <memlayout.h>
- #include <atomic.h>
- #include <assert.h>
- 
- // pmm_manager is a physical memory management class. A special pmm manager - XXX_pmm_manager
- // only needs to implement the methods in pmm_manager class, then XXX_pmm_manager can be used
- // by ucore to manage the total physical memory space.
- struct pmm_manager {
-     const char *name;                                 // XXX_pmm_manager's name
-     void (*init)(void);                               // initialize internal description&management data structure
-                                                       // (free block list, number of free block) of XXX_pmm_manager 
-     void (*init_memmap)(struct Page *base, size_t n); // setup description&management data structcure according to
-                                                       // the initial free physical memory space 
-     struct Page *(*alloc_pages)(size_t n);            // allocate >=n pages, depend on the allocation algorithm 
-     void (*free_pages)(struct Page *base, size_t n);  // free >=n pages with "base" addr of Page descriptor structures(memlayout.h)
-     size_t (*nr_free_pages)(void);                    // return the number of free pages 
-     void (*check)(void);                              // check the correctness of XXX_pmm_manager 
- };
- 
- extern const struct pmm_manager *pmm_manager;
- extern pde_t *boot_pgdir;
- extern uintptr_t boot_cr3;
- 
  void pmm_init(void);
  
- struct Page *alloc_pages(size_t n);
- void free_pages(struct Page *base, size_t n);
- size_t nr_free_pages(void);
- 
- #define alloc_page() alloc_pages(1)
- #define free_page(page) free_pages(page, 1)
- 
- pte_t *get_pte(pde_t *pgdir, uintptr_t la, bool create);
- struct Page *get_page(pde_t *pgdir, uintptr_t la, pte_t **ptep_store);
- void page_remove(pde_t *pgdir, uintptr_t la);
- int page_insert(pde_t *pgdir, struct Page *page, uintptr_t la, uint32_t perm);
- 
- void load_esp0(uintptr_t esp0);
- void tlb_invalidate(pde_t *pgdir, uintptr_t la);
- 
- void print_pgdir(void);
- 
- /* *
-  * PADDR - takes a kernel virtual address (an address that points above KERNBASE),
-  * where the machine's maximum 256MB of physical memory is mapped and returns the
-  * corresponding physical address.  It panics if you pass it a non-kernel virtual address.
-  * */
- #define PADDR(kva) ({                                                   \
-             uintptr_t __m_kva = (uintptr_t)(kva);                       \
-             if (__m_kva < KERNBASE) {                                   \
-                 panic("PADDR called with invalid kva %08lx", __m_kva);  \
-             }                                                           \
-             __m_kva - KERNBASE;                                         \
-         })
- 
- /* *
-  * KADDR - takes a physical address and returns the corresponding kernel virtual
-  * address. It panics if you pass an invalid physical address.
-  * */
- #define KADDR(pa) ({                                                    \
-             uintptr_t __m_pa = (pa);                                    \
-             size_t __m_ppn = PPN(__m_pa);                               \
-             if (__m_ppn >= npage) {                                     \
-                 panic("KADDR called with invalid pa %08lx", __m_pa);    \
-             }                                                           \
-             (void *) (__m_pa + KERNBASE);                               \
-         })
- 
- extern struct Page *pages;
- extern size_t npage;
- 
- static inline ppn_t
- page2ppn(struct Page *page) {
-     return page - pages;
- }
- 
- static inline uintptr_t
- page2pa(struct Page *page) {
-     return page2ppn(page) << PGSHIFT;
- }
- 
- static inline struct Page *
- pa2page(uintptr_t pa) {
-     if (PPN(pa) >= npage) {
-         panic("pa2page called with invalid pa");
-     }
-     return &pages[PPN(pa)];
- }
- 
- static inline void *
- page2kva(struct Page *page) {
-     return KADDR(page2pa(page));
- }
- 
- static inline struct Page *
- kva2page(void *kva) {
-     return pa2page(PADDR(kva));
- }
- 
- static inline struct Page *
- pte2page(pte_t pte) {
-     if (!(pte & PTE_P)) {
-         panic("pte2page called with invalid pte");
-     }
-     return pa2page(PTE_ADDR(pte));
- }
- 
- static inline struct Page *
- pde2page(pde_t pde) {
-     return pa2page(PDE_ADDR(pde));
- }
- 
- static inline int
- page_ref(struct Page *page) {
-     return page->ref;
- }
- 
- static inline void
- set_page_ref(struct Page *page, int val) {
-     page->ref = val;
- }
- 
- static inline int
- page_ref_inc(struct Page *page) {
-     page->ref += 1;
-     return page->ref;
- }
- 
- static inline int
- page_ref_dec(struct Page *page) {
-     page->ref -= 1;
-     return page->ref;
- }
- 
- extern char bootstack[], bootstacktop[];
- 
  #endif /* !__KERN_MM_PMM_H__ */
  
--- 1,7 ----
  #ifndef __KERN_MM_PMM_H__
  #define __KERN_MM_PMM_H__
  
  void pmm_init(void);
  
  #endif /* !__KERN_MM_PMM_H__ */
  
*** trap.c	2018-04-02 22:38:25.894675883 +0800
--- trap.c	2018-05-02 22:13:09.282766603 +0800
***************
*** 46,51 ****
        *     You don't know the meaning of this instruction? just google it! and check the libs/x86.h to know more.
        *     Notice: the argument of lidt is idt_pd. try to find it!
        */
  }
  
  static const char *
--- 46,58 ----
        *     You don't know the meaning of this instruction? just google it! and check the libs/x86.h to know more.
        *     Notice: the argument of lidt is idt_pd. try to find it!
        */
+ 		extern uintptr_t __vectors[] ;
+ 		int i;                                        
+ 		for(i=0;i<256;i++){
+ 			SETGATE(idt[i],0,GD_KTEXT,__vectors[i],DPL_KERNEL);
+ 		}
+ 		
+ 		lidt(&idt_pd);
  }
  
  static const char *
***************
*** 147,152 ****
           * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().
           * (3) Too Simple? Yes, I think so!
           */
          break;
      case IRQ_OFFSET + IRQ_COM1:
          c = cons_getc();
--- 154,164 ----
           * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().
           * (3) Too Simple? Yes, I think so!
           */
+ 		ticks++;
+ 		if(ticks%100==0){
+ 			print_ticks();
+ 		}
+ 		
          break;
      case IRQ_OFFSET + IRQ_COM1:
          c = cons_getc();
***************
*** 185,187 ****
      trap_dispatch(tf);
  }
  
--- 197,217 ----
      trap_dispatch(tf);
  }
  
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
*** trap.h	2018-04-02 22:38:25.894675883 +0800
--- trap.h	2018-04-02 22:38:25.890675642 +0800
***************
*** 6,44 ****
  /* Trap Numbers */
  
  /* Processor-defined: */
! #define T_DIVIDE                0   // divide error
! #define T_DEBUG                 1   // debug exception
! #define T_NMI                   2   // non-maskable interrupt
! #define T_BRKPT                 3   // breakpoint
! #define T_OFLOW                 4   // overflow
! #define T_BOUND                 5   // bounds check
! #define T_ILLOP                 6   // illegal opcode
! #define T_DEVICE                7   // device not available
! #define T_DBLFLT                8   // double fault
! // #define T_COPROC             9   // reserved (not used since 486)
! #define T_TSS                   10  // invalid task switch segment
! #define T_SEGNP                 11  // segment not present
! #define T_STACK                 12  // stack exception
! #define T_GPFLT                 13  // general protection fault
! #define T_PGFLT                 14  // page fault
! // #define T_RES                15  // reserved
! #define T_FPERR                 16  // floating point error
! #define T_ALIGN                 17  // aligment check
! #define T_MCHK                  18  // machine check
! #define T_SIMDERR               19  // SIMD floating point error
  
  #define T_SYSCALL               0x80 // SYSCALL, ONLY FOR THIS PROJ
  
  /* Hardware IRQ numbers. We receive these as (IRQ_OFFSET + IRQ_xx) */
! #define IRQ_OFFSET              32  // IRQ 0 corresponds to int IRQ_OFFSET
  
! #define IRQ_TIMER               0
! #define IRQ_KBD                 1
  #define IRQ_COM1                4
  #define IRQ_IDE1                14
  #define IRQ_IDE2                15
! #define IRQ_ERROR               19
! #define IRQ_SPURIOUS            31
  
  /* *
   * These are arbitrarily chosen, but with care not to overlap
--- 6,44 ----
  /* Trap Numbers */
  
  /* Processor-defined: */
! #define T_DIVIDE                0    // divide error
! #define T_DEBUG                    1    // debug exception
! #define T_NMI                    2    // non-maskable interrupt
! #define T_BRKPT                    3    // breakpoint
! #define T_OFLOW                    4    // overflow
! #define T_BOUND                    5    // bounds check
! #define T_ILLOP                    6    // illegal opcode
! #define T_DEVICE                7    // device not available
! #define T_DBLFLT                8    // double fault
! // #define T_COPROC                9    // reserved (not used since 486)
! #define T_TSS                    10    // invalid task switch segment
! #define T_SEGNP                    11    // segment not present
! #define T_STACK                    12    // stack exception
! #define T_GPFLT                    13    // general protection fault
! #define T_PGFLT                    14    // page fault
! // #define T_RES                15    // reserved
! #define T_FPERR                    16    // floating point error
! #define T_ALIGN                    17    // aligment check
! #define T_MCHK                    18    // machine check
! #define T_SIMDERR                19    // SIMD floating point error
  
  #define T_SYSCALL               0x80 // SYSCALL, ONLY FOR THIS PROJ
  
  /* Hardware IRQ numbers. We receive these as (IRQ_OFFSET + IRQ_xx) */
! #define IRQ_OFFSET                32    // IRQ 0 corresponds to int IRQ_OFFSET
  
! #define IRQ_TIMER                0
! #define IRQ_KBD                    1
  #define IRQ_COM1                4
  #define IRQ_IDE1                14
  #define IRQ_IDE2                15
! #define IRQ_ERROR                19
! #define IRQ_SPURIOUS                31
  
  /* *
   * These are arbitrarily chosen, but with care not to overlap
***************
*** 52,58 ****
      uint32_t reg_edi;
      uint32_t reg_esi;
      uint32_t reg_ebp;
!     uint32_t reg_oesp;          /* Useless */
      uint32_t reg_ebx;
      uint32_t reg_edx;
      uint32_t reg_ecx;
--- 52,58 ----
      uint32_t reg_edi;
      uint32_t reg_esi;
      uint32_t reg_ebp;
!     uint32_t reg_oesp;            /* Useless */
      uint32_t reg_ebx;
      uint32_t reg_edx;
      uint32_t reg_ecx;
*** elf.h	2018-04-02 22:38:25.894675883 +0800
--- elf.h	2018-04-02 22:38:25.890675642 +0800
***************
*** 3,9 ****
  
  #include <defs.h>
  
! #define ELF_MAGIC   0x464C457FU         // "\x7FELF" in little endian
  
  /* file header */
  struct elfhdr {
--- 3,9 ----
  
  #include <defs.h>
  
! #define ELF_MAGIC    0x464C457FU            // "\x7FELF" in little endian
  
  /* file header */
  struct elfhdr {
*** error.h	2018-04-02 22:38:25.894675883 +0800
--- error.h	2018-04-02 22:38:25.890675642 +0800
***************
*** 2,13 ****
  #define __LIBS_ERROR_H__
  
  /* kernel error codes -- keep in sync with list in lib/printfmt.c */
! #define E_UNSPECIFIED       1   // Unspecified or unknown problem
! #define E_BAD_PROC          2   // Process doesn't exist or otherwise
! #define E_INVAL             3   // Invalid parameter
! #define E_NO_MEM            4   // Request failed due to memory shortage
! #define E_NO_FREE_PROC      5   // Attempt to create a new process beyond
! #define E_FAULT             6   // Memory fault
  
  /* the maximum allowed */
  #define MAXERROR            6
--- 2,13 ----
  #define __LIBS_ERROR_H__
  
  /* kernel error codes -- keep in sync with list in lib/printfmt.c */
! #define E_UNSPECIFIED        1    // Unspecified or unknown problem
! #define E_BAD_PROC            2    // Process doesn't exist or otherwise
! #define E_INVAL                3    // Invalid parameter
! #define E_NO_MEM            4    // Request failed due to memory shortage
! #define E_NO_FREE_PROC        5    // Attempt to create a new process beyond
! #define E_FAULT                6    // Memory fault
  
  /* the maximum allowed */
  #define MAXERROR            6
*** printfmt.c	2018-04-02 22:38:25.894675883 +0800
--- printfmt.c	2018-04-02 22:38:25.890675642 +0800
***************
*** 15,37 ****
   * */
  
  static const char * const error_string[MAXERROR + 1] = {
!     [0]                     NULL,
!     [E_UNSPECIFIED]         "unspecified error",
      [E_BAD_PROC]            "bad process",
!     [E_INVAL]               "invalid parameter",
!     [E_NO_MEM]              "out of memory",
      [E_NO_FREE_PROC]        "out of processes",
!     [E_FAULT]               "segmentation fault",
  };
  
  /* *
   * printnum - print a number (base <= 16) in reverse order
!  * @putch:      specified putch function, print a single character
!  * @putdat:     used by @putch function
   * @num:        the number will be printed
!  * @base:       base for print, must be in [1, 16]
!  * @width:      maximum number of digits, if the actual width is less than @width, use @padc instead
!  * @padc:       character that padded on the left if the actual width is less than @width
   * */
  static void
  printnum(void (*putch)(int, void*), void *putdat,
--- 15,37 ----
   * */
  
  static const char * const error_string[MAXERROR + 1] = {
!     [0]                        NULL,
!     [E_UNSPECIFIED]            "unspecified error",
      [E_BAD_PROC]            "bad process",
!     [E_INVAL]                "invalid parameter",
!     [E_NO_MEM]                "out of memory",
      [E_NO_FREE_PROC]        "out of processes",
!     [E_FAULT]                "segmentation fault",
  };
  
  /* *
   * printnum - print a number (base <= 16) in reverse order
!  * @putch:        specified putch function, print a single character
!  * @putdat:        used by @putch function
   * @num:        the number will be printed
!  * @base:        base for print, must be in [1, 16]
!  * @width:         maximum number of digits, if the actual width is less than @width, use @padc instead
!  * @padc:        character that padded on the left if the actual width is less than @width
   * */
  static void
  printnum(void (*putch)(int, void*), void *putdat,
***************
*** 53,60 ****
  
  /* *
   * getuint - get an unsigned int of various possible sizes from a varargs list
!  * @ap:         a varargs list pointer
!  * @lflag:      determines the size of the vararg that @ap points to
   * */
  static unsigned long long
  getuint(va_list *ap, int lflag) {
--- 53,60 ----
  
  /* *
   * getuint - get an unsigned int of various possible sizes from a varargs list
!  * @ap:            a varargs list pointer
!  * @lflag:        determines the size of the vararg that @ap points to
   * */
  static unsigned long long
  getuint(va_list *ap, int lflag) {
***************
*** 71,78 ****
  
  /* *
   * getint - same as getuint but signed, we can't use getuint because of sign extension
!  * @ap:         a varargs list pointer
!  * @lflag:      determines the size of the vararg that @ap points to
   * */
  static long long
  getint(va_list *ap, int lflag) {
--- 71,78 ----
  
  /* *
   * getint - same as getuint but signed, we can't use getuint because of sign extension
!  * @ap:            a varargs list pointer
!  * @lflag:        determines the size of the vararg that @ap points to
   * */
  static long long
  getint(va_list *ap, int lflag) {
***************
*** 89,96 ****
  
  /* *
   * printfmt - format a string and print it by using putch
!  * @putch:      specified putch function, print a single character
!  * @putdat:     used by @putch function
   * @fmt:        the format string to use
   * */
  void
--- 89,96 ----
  
  /* *
   * printfmt - format a string and print it by using putch
!  * @putch:        specified putch function, print a single character
!  * @putdat:        used by @putch function
   * @fmt:        the format string to use
   * */
  void
***************
*** 105,114 ****
  /* *
   * vprintfmt - format a string and print it by using putch, it's called with a va_list
   * instead of a variable number of arguments
!  * @putch:      specified putch function, print a single character
!  * @putdat:     used by @putch function
   * @fmt:        the format string to use
!  * @ap:         arguments for the format string
   *
   * Call this function if you are already dealing with a va_list.
   * Or you probably want printfmt() instead.
--- 105,114 ----
  /* *
   * vprintfmt - format a string and print it by using putch, it's called with a va_list
   * instead of a variable number of arguments
!  * @putch:        specified putch function, print a single character
!  * @putdat:        used by @putch function
   * @fmt:        the format string to use
!  * @ap:            arguments for the format string
   *
   * Call this function if you are already dealing with a va_list.
   * Or you probably want printfmt() instead.
***************
*** 277,291 ****
  
  /* sprintbuf is used to save enough information of a buffer */
  struct sprintbuf {
!     char *buf;          // address pointer points to the first unused memory
!     char *ebuf;         // points the end of the buffer
      int cnt;            // the number of characters that have been placed in this buffer
  };
  
  /* *
   * sprintputch - 'print' a single character in a buffer
!  * @ch:         the character will be printed
!  * @b:          the buffer to place the character @ch
   * */
  static void
  sprintputch(int ch, struct sprintbuf *b) {
--- 277,291 ----
  
  /* sprintbuf is used to save enough information of a buffer */
  struct sprintbuf {
!     char *buf;            // address pointer points to the first unused memory
!     char *ebuf;            // points the end of the buffer
      int cnt;            // the number of characters that have been placed in this buffer
  };
  
  /* *
   * sprintputch - 'print' a single character in a buffer
!  * @ch:            the character will be printed
!  * @b:            the buffer to place the character @ch
   * */
  static void
  sprintputch(int ch, struct sprintbuf *b) {
***************
*** 298,304 ****
  /* *
   * snprintf - format a string and place it in a buffer
   * @str:        the buffer to place the result into
!  * @size:       the size of buffer, including the trailing null space
   * @fmt:        the format string to use
   * */
  int
--- 298,304 ----
  /* *
   * snprintf - format a string and place it in a buffer
   * @str:        the buffer to place the result into
!  * @size:        the size of buffer, including the trailing null space
   * @fmt:        the format string to use
   * */
  int
***************
*** 315,323 ****
   * vsnprintf - format a string and place it in a buffer, it's called with a va_list
   * instead of a variable number of arguments
   * @str:        the buffer to place the result into
!  * @size:       the size of buffer, including the trailing null space
   * @fmt:        the format string to use
!  * @ap:         arguments for the format string
   *
   * The return value is the number of characters which would be generated for the
   * given input, excluding the trailing '\0'.
--- 315,323 ----
   * vsnprintf - format a string and place it in a buffer, it's called with a va_list
   * instead of a variable number of arguments
   * @str:        the buffer to place the result into
!  * @size:        the size of buffer, including the trailing null space
   * @fmt:        the format string to use
!  * @ap:            arguments for the format string
   *
   * The return value is the number of characters which would be generated for the
   * given input, excluding the trailing '\0'.
*** string.c	2018-04-02 22:38:25.894675883 +0800
--- string.c	2018-04-02 22:38:25.890675642 +0800
***************
*** 4,10 ****
  /* *
   * strlen - calculate the length of the string @s, not including
   * the terminating '\0' character.
!  * @s:      the input string
   *
   * The strlen() function returns the length of string @s.
   * */
--- 4,10 ----
  /* *
   * strlen - calculate the length of the string @s, not including
   * the terminating '\0' character.
!  * @s:        the input string
   *
   * The strlen() function returns the length of string @s.
   * */
***************
*** 20,26 ****
  /* *
   * strnlen - calculate the length of the string @s, not including
   * the terminating '\0' char acter, but at most @len.
!  * @s:      the input string
   * @len:    the max-length that function will scan
   *
   * Note that, this function looks only at the first @len characters
--- 20,26 ----
  /* *
   * strnlen - calculate the length of the string @s, not including
   * the terminating '\0' char acter, but at most @len.
!  * @s:        the input string
   * @len:    the max-length that function will scan
   *
   * Note that, this function looks only at the first @len characters
***************
*** 87,94 ****
  
  /* *
   * strcmp - compares the string @s1 and @s2
!  * @s1:     string to be compared
!  * @s2:     string to be compared
   *
   * This function starts comparing the first character of each string. If
   * they are equal to each other, it continues with the following pairs until
--- 87,94 ----
  
  /* *
   * strcmp - compares the string @s1 and @s2
!  * @s1:        string to be compared
!  * @s2:        string to be compared
   *
   * This function starts comparing the first character of each string. If
   * they are equal to each other, it continues with the following pairs until
***************
*** 114,122 ****
  
  /* *
   * strncmp - compares up to @n characters of the string @s1 to those of the string @s2
!  * @s1:     string to be compared
!  * @s2:     string to be compared
!  * @n:      maximum number of characters to compare
   *
   * This function starts comparing the first character of each string. If
   * they are equal to each other, it continues with the following pairs until
--- 114,122 ----
  
  /* *
   * strncmp - compares up to @n characters of the string @s1 to those of the string @s2
!  * @s1:        string to be compared
!  * @s2:        string to be compared
!  * @n:        maximum number of characters to compare
   *
   * This function starts comparing the first character of each string. If
   * they are equal to each other, it continues with the following pairs until
***************
*** 133,140 ****
  
  /* *
   * strchr - locates first occurrence of character in string
!  * @s:      the input string
!  * @c:      character to be located
   *
   * The strchr() function returns a pointer to the first occurrence of
   * character in @s. If the value is not found, the function returns 'NULL'.
--- 133,140 ----
  
  /* *
   * strchr - locates first occurrence of character in string
!  * @s:        the input string
!  * @c:        character to be located
   *
   * The strchr() function returns a pointer to the first occurrence of
   * character in @s. If the value is not found, the function returns 'NULL'.
***************
*** 152,159 ****
  
  /* *
   * strfind - locates first occurrence of character in string
!  * @s:      the input string
!  * @c:      character to be located
   *
   * The strfind() function is like strchr() except that if @c is
   * not found in @s, then it returns a pointer to the null byte at the
--- 152,159 ----
  
  /* *
   * strfind - locates first occurrence of character in string
!  * @s:        the input string
!  * @c:        character to be located
   *
   * The strfind() function is like strchr() except that if @c is
   * not found in @s, then it returns a pointer to the null byte at the
***************
*** 172,182 ****
  
  /* *
   * strtol - converts string to long integer
!  * @s:      the input string that contains the representation of an integer number
!  * @endptr: reference to an object of type char *, whose value is set by the
!  *          function to the next character in @s after the numerical value. This
!  *          parameter can also be a null pointer, in which case it is not used.
!  * @base:   x
   *
   * The function first discards as many whitespace characters as necessary until
   * the first non-whitespace character is found. Then, starting from this character,
--- 172,182 ----
  
  /* *
   * strtol - converts string to long integer
!  * @s:        the input string that contains the representation of an integer number
!  * @endptr:    reference to an object of type char *, whose value is set by the
!  *             function to the next character in @s after the numerical value. This
!  *             parameter can also be a null pointer, in which case it is not used.
!  * @base:    x
   *
   * The function first discards as many whitespace characters as necessary until
   * the first non-whitespace character is found. Then, starting from this character,
***************
*** 261,269 ****
  /* *
   * memset - sets the first @n bytes of the memory area pointed by @s
   * to the specified value @c.
!  * @s:      pointer the the memory area to fill
!  * @c:      value to set
!  * @n:      number of bytes to be set to the value
   *
   * The memset() function returns @s.
   * */
--- 261,269 ----
  /* *
   * memset - sets the first @n bytes of the memory area pointed by @s
   * to the specified value @c.
!  * @s:        pointer the the memory area to fill
!  * @c:        value to set
!  * @n:        number of bytes to be set to the value
   *
   * The memset() function returns @s.
   * */
***************
*** 283,291 ****
  /* *
   * memmove - copies the values of @n bytes from the location pointed by @src to
   * the memory area pointed by @dst. @src and @dst are allowed to overlap.
!  * @dst     pointer to the destination array where the content is to be copied
!  * @src     pointer to the source of data to by copied
!  * @n:      number of bytes to copy
   *
   * The memmove() function returns @dst.
   * */
--- 283,291 ----
  /* *
   * memmove - copies the values of @n bytes from the location pointed by @src to
   * the memory area pointed by @dst. @src and @dst are allowed to overlap.
!  * @dst        pointer to the destination array where the content is to be copied
!  * @src        pointer to the source of data to by copied
!  * @n:        number of bytes to copy
   *
   * The memmove() function returns @dst.
   * */
***************
*** 313,321 ****
  /* *
   * memcpy - copies the value of @n bytes from the location pointed by @src to
   * the memory area pointed by @dst.
!  * @dst     pointer to the destination array where the content is to be copied
!  * @src     pointer to the source of data to by copied
!  * @n:      number of bytes to copy
   *
   * The memcpy() returns @dst.
   *
--- 313,321 ----
  /* *
   * memcpy - copies the value of @n bytes from the location pointed by @src to
   * the memory area pointed by @dst.
!  * @dst        pointer to the destination array where the content is to be copied
!  * @src        pointer to the source of data to by copied
!  * @n:        number of bytes to copy
   *
   * The memcpy() returns @dst.
   *
***************
*** 340,348 ****
  
  /* *
   * memcmp - compares two blocks of memory
!  * @v1:     pointer to block of memory
!  * @v2:     pointer to block of memory
!  * @n:      number of bytes to compare
   *
   * The memcmp() functions returns an integral value indicating the
   * relationship between the content of the memory blocks:
--- 340,348 ----
  
  /* *
   * memcmp - compares two blocks of memory
!  * @v1:        pointer to block of memory
!  * @v2:        pointer to block of memory
!  * @n:        number of bytes to compare
   *
   * The memcmp() functions returns an integral value indicating the
   * relationship between the content of the memory blocks:
*** x86.h	2018-04-02 22:38:25.894675883 +0800
--- x86.h	2018-04-02 22:38:25.890675642 +0800
***************
*** 3,90 ****
  
  #include <defs.h>
  
! #define do_div(n, base) ({                                          \
!             unsigned long __upper, __low, __high, __mod, __base;    \
!             __base = (base);                                        \
!             asm ("" : "=a" (__low), "=d" (__high) : "A" (n));       \
!             __upper = __high;                                       \
!             if (__high != 0) {                                      \
!                 __upper = __high % __base;                          \
!                 __high = __high / __base;                           \
!             }                                                       \
!             asm ("divl %2" : "=a" (__low), "=d" (__mod)             \
!                 : "rm" (__base), "0" (__low), "1" (__upper));       \
!             asm ("" : "=A" (n) : "a" (__low), "d" (__high));        \
!             __mod;                                                  \
!         })
! 
! #define barrier() __asm__ __volatile__ ("" ::: "memory")
  
  static inline uint8_t inb(uint16_t port) __attribute__((always_inline));
  static inline void insl(uint32_t port, void *addr, int cnt) __attribute__((always_inline));
  static inline void outb(uint16_t port, uint8_t data) __attribute__((always_inline));
  static inline void outw(uint16_t port, uint16_t data) __attribute__((always_inline));
- static inline void outsl(uint32_t port, const void *addr, int cnt) __attribute__((always_inline));
  static inline uint32_t read_ebp(void) __attribute__((always_inline));
- static inline void breakpoint(void) __attribute__((always_inline));
- static inline uint32_t read_dr(unsigned regnum) __attribute__((always_inline));
- static inline void write_dr(unsigned regnum, uint32_t value) __attribute__((always_inline));
  
  /* Pseudo-descriptors used for LGDT, LLDT(not used) and LIDT instructions. */
  struct pseudodesc {
      uint16_t pd_lim;        // Limit
!     uintptr_t pd_base;      // Base address
  } __attribute__ ((packed));
  
  static inline void lidt(struct pseudodesc *pd) __attribute__((always_inline));
  static inline void sti(void) __attribute__((always_inline));
  static inline void cli(void) __attribute__((always_inline));
  static inline void ltr(uint16_t sel) __attribute__((always_inline));
- static inline uint32_t read_eflags(void) __attribute__((always_inline));
- static inline void write_eflags(uint32_t eflags) __attribute__((always_inline));
- static inline void lcr0(uintptr_t cr0) __attribute__((always_inline));
- static inline void lcr3(uintptr_t cr3) __attribute__((always_inline));
- static inline uintptr_t rcr0(void) __attribute__((always_inline));
- static inline uintptr_t rcr1(void) __attribute__((always_inline));
- static inline uintptr_t rcr2(void) __attribute__((always_inline));
- static inline uintptr_t rcr3(void) __attribute__((always_inline));
- static inline void invlpg(void *addr) __attribute__((always_inline));
  
  static inline uint8_t
  inb(uint16_t port) {
      uint8_t data;
!     asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");
      return data;
  }
  
  static inline void
  insl(uint32_t port, void *addr, int cnt) {
      asm volatile (
!         "cld;"
!         "repne; insl;"
!         : "=D" (addr), "=c" (cnt)
!         : "d" (port), "0" (addr), "1" (cnt)
!         : "memory", "cc");
  }
  
  static inline void
  outb(uint16_t port, uint8_t data) {
!     asm volatile ("outb %0, %1" :: "a" (data), "d" (port) : "memory");
  }
  
  static inline void
  outw(uint16_t port, uint16_t data) {
!     asm volatile ("outw %0, %1" :: "a" (data), "d" (port) : "memory");
! }
! 
! static inline void
! outsl(uint32_t port, const void *addr, int cnt) {
!     asm volatile (
!         "cld;"
!         "repne; outsl;"
!         : "=S" (addr), "=c" (cnt)
!         : "d" (port), "0" (addr), "1" (cnt)
!         : "memory", "cc");
  }
  
  static inline uint32_t
--- 3,65 ----
  
  #include <defs.h>
  
! #define do_div(n, base) ({                                        \
!     unsigned long __upper, __low, __high, __mod, __base;        \
!     __base = (base);                                            \
!     asm("" : "=a" (__low), "=d" (__high) : "A" (n));            \
!     __upper = __high;                                            \
!     if (__high != 0) {                                            \
!         __upper = __high % __base;                                \
!         __high = __high / __base;                                \
!     }                                                            \
!     asm("divl %2" : "=a" (__low), "=d" (__mod)                    \
!         : "rm" (__base), "0" (__low), "1" (__upper));            \
!     asm("" : "=A" (n) : "a" (__low), "d" (__high));                \
!     __mod;                                                        \
!  })
  
  static inline uint8_t inb(uint16_t port) __attribute__((always_inline));
  static inline void insl(uint32_t port, void *addr, int cnt) __attribute__((always_inline));
  static inline void outb(uint16_t port, uint8_t data) __attribute__((always_inline));
  static inline void outw(uint16_t port, uint16_t data) __attribute__((always_inline));
  static inline uint32_t read_ebp(void) __attribute__((always_inline));
  
  /* Pseudo-descriptors used for LGDT, LLDT(not used) and LIDT instructions. */
  struct pseudodesc {
      uint16_t pd_lim;        // Limit
!     uint32_t pd_base;        // Base address
  } __attribute__ ((packed));
  
  static inline void lidt(struct pseudodesc *pd) __attribute__((always_inline));
  static inline void sti(void) __attribute__((always_inline));
  static inline void cli(void) __attribute__((always_inline));
  static inline void ltr(uint16_t sel) __attribute__((always_inline));
  
  static inline uint8_t
  inb(uint16_t port) {
      uint8_t data;
!     asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
      return data;
  }
  
  static inline void
  insl(uint32_t port, void *addr, int cnt) {
      asm volatile (
!             "cld;"
!             "repne; insl;"
!             : "=D" (addr), "=c" (cnt)
!             : "d" (port), "0" (addr), "1" (cnt)
!             : "memory", "cc");
  }
  
  static inline void
  outb(uint16_t port, uint8_t data) {
!     asm volatile ("outb %0, %1" :: "a" (data), "d" (port));
  }
  
  static inline void
  outw(uint16_t port, uint16_t data) {
!     asm volatile ("outw %0, %1" :: "a" (data), "d" (port));
  }
  
  static inline uint32_t
***************
*** 95,133 ****
  }
  
  static inline void
- breakpoint(void) {
-     asm volatile ("int $3");
- }
- 
- static inline uint32_t
- read_dr(unsigned regnum) {
-     uint32_t value = 0;
-     switch (regnum) {
-     case 0: asm volatile ("movl %%db0, %0" : "=r" (value)); break;
-     case 1: asm volatile ("movl %%db1, %0" : "=r" (value)); break;
-     case 2: asm volatile ("movl %%db2, %0" : "=r" (value)); break;
-     case 3: asm volatile ("movl %%db3, %0" : "=r" (value)); break;
-     case 6: asm volatile ("movl %%db6, %0" : "=r" (value)); break;
-     case 7: asm volatile ("movl %%db7, %0" : "=r" (value)); break;
-     }
-     return value;
- }
- 
- static void
- write_dr(unsigned regnum, uint32_t value) {
-     switch (regnum) {
-     case 0: asm volatile ("movl %0, %%db0" :: "r" (value)); break;
-     case 1: asm volatile ("movl %0, %%db1" :: "r" (value)); break;
-     case 2: asm volatile ("movl %0, %%db2" :: "r" (value)); break;
-     case 3: asm volatile ("movl %0, %%db3" :: "r" (value)); break;
-     case 6: asm volatile ("movl %0, %%db6" :: "r" (value)); break;
-     case 7: asm volatile ("movl %0, %%db7" :: "r" (value)); break;
-     }
- }
- 
- static inline void
  lidt(struct pseudodesc *pd) {
!     asm volatile ("lidt (%0)" :: "r" (pd) : "memory");
  }
  
  static inline void
--- 70,77 ----
  }
  
  static inline void
  lidt(struct pseudodesc *pd) {
!     asm volatile ("lidt (%0)" :: "r" (pd));
  }
  
  static inline void
***************
*** 137,203 ****
  
  static inline void
  cli(void) {
!     asm volatile ("cli" ::: "memory");
  }
  
  static inline void
  ltr(uint16_t sel) {
!     asm volatile ("ltr %0" :: "r" (sel) : "memory");
! }
! 
! static inline uint32_t
! read_eflags(void) {
!     uint32_t eflags;
!     asm volatile ("pushfl; popl %0" : "=r" (eflags));
!     return eflags;
! }
! 
! static inline void
! write_eflags(uint32_t eflags) {
!     asm volatile ("pushl %0; popfl" :: "r" (eflags));
! }
! 
! static inline void
! lcr0(uintptr_t cr0) {
!     asm volatile ("mov %0, %%cr0" :: "r" (cr0) : "memory");
! }
! 
! static inline void
! lcr3(uintptr_t cr3) {
!     asm volatile ("mov %0, %%cr3" :: "r" (cr3) : "memory");
! }
! 
! static inline uintptr_t
! rcr0(void) {
!     uintptr_t cr0;
!     asm volatile ("mov %%cr0, %0" : "=r" (cr0) :: "memory");
!     return cr0;
! }
! 
! static inline uintptr_t
! rcr1(void) {
!     uintptr_t cr1;
!     asm volatile ("mov %%cr1, %0" : "=r" (cr1) :: "memory");
!     return cr1;
! }
! 
! static inline uintptr_t
! rcr2(void) {
!     uintptr_t cr2;
!     asm volatile ("mov %%cr2, %0" : "=r" (cr2) :: "memory");
!     return cr2;
! }
! 
! static inline uintptr_t
! rcr3(void) {
!     uintptr_t cr3;
!     asm volatile ("mov %%cr3, %0" : "=r" (cr3) :: "memory");
!     return cr3;
! }
! 
! static inline void
! invlpg(void *addr) {
!     asm volatile ("invlpg (%0)" :: "r" (addr) : "memory");
  }
  
  static inline int __strcmp(const char *s1, const char *s2) __attribute__((always_inline));
--- 81,92 ----
  
  static inline void
  cli(void) {
!     asm volatile ("cli");
  }
  
  static inline void
  ltr(uint16_t sel) {
!     asm volatile ("ltr %0" :: "r" (sel));
  }
  
  static inline int __strcmp(const char *s1, const char *s2) __attribute__((always_inline));
***************
*** 212,230 ****
  __strcmp(const char *s1, const char *s2) {
      int d0, d1, ret;
      asm volatile (
!         "1: lodsb;"
!         "scasb;"
!         "jne 2f;"
!         "testb %%al, %%al;"
!         "jne 1b;"
!         "xorl %%eax, %%eax;"
!         "jmp 3f;"
!         "2: sbbl %%eax, %%eax;"
!         "orb $1, %%al;"
!         "3:"
!         : "=a" (ret), "=&S" (d0), "=&D" (d1)
!         : "1" (s1), "2" (s2)
!         : "memory");
      return ret;
  }
  
--- 101,119 ----
  __strcmp(const char *s1, const char *s2) {
      int d0, d1, ret;
      asm volatile (
!             "1: lodsb;"
!             "scasb;"
!             "jne 2f;"
!             "testb %%al, %%al;"
!             "jne 1b;"
!             "xorl %%eax, %%eax;"
!             "jmp 3f;"
!             "2: sbbl %%eax, %%eax;"
!             "orb $1, %%al;"
!             "3:"
!             : "=a" (ret), "=&S" (d0), "=&D" (d1)
!             : "1" (s1), "2" (s2)
!             : "memory");
      return ret;
  }
  
***************
*** 236,247 ****
  __strcpy(char *dst, const char *src) {
      int d0, d1, d2;
      asm volatile (
!         "1: lodsb;"
!         "stosb;"
!         "testb %%al, %%al;"
!         "jne 1b;"
!         : "=&S" (d0), "=&D" (d1), "=&a" (d2)
!         : "0" (src), "1" (dst) : "memory");
      return dst;
  }
  #endif /* __HAVE_ARCH_STRCPY */
--- 125,136 ----
  __strcpy(char *dst, const char *src) {
      int d0, d1, d2;
      asm volatile (
!             "1: lodsb;"
!             "stosb;"
!             "testb %%al, %%al;"
!             "jne 1b;"
!             : "=&S" (d0), "=&D" (d1), "=&a" (d2)
!             : "0" (src), "1" (dst) : "memory");
      return dst;
  }
  #endif /* __HAVE_ARCH_STRCPY */
***************
*** 252,261 ****
  __memset(void *s, char c, size_t n) {
      int d0, d1;
      asm volatile (
!         "rep; stosb;"
!         : "=&c" (d0), "=&D" (d1)
!         : "0" (n), "a" (c), "1" (s)
!         : "memory");
      return s;
  }
  #endif /* __HAVE_ARCH_MEMSET */
--- 141,150 ----
  __memset(void *s, char c, size_t n) {
      int d0, d1;
      asm volatile (
!             "rep; stosb;"
!             : "=&c" (d0), "=&D" (d1)
!             : "0" (n), "a" (c), "1" (s)
!             : "memory");
      return s;
  }
  #endif /* __HAVE_ARCH_MEMSET */
***************
*** 269,280 ****
      }
      int d0, d1, d2;
      asm volatile (
!         "std;"
!         "rep; movsb;"
!         "cld;"
!         : "=&c" (d0), "=&S" (d1), "=&D" (d2)
!         : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
!         : "memory");
      return dst;
  }
  #endif /* __HAVE_ARCH_MEMMOVE */
--- 158,169 ----
      }
      int d0, d1, d2;
      asm volatile (
!             "std;"
!             "rep; movsb;"
!             "cld;"
!             : "=&c" (d0), "=&S" (d1), "=&D" (d2)
!             : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
!             : "memory");
      return dst;
  }
  #endif /* __HAVE_ARCH_MEMMOVE */
***************
*** 285,299 ****
  __memcpy(void *dst, const void *src, size_t n) {
      int d0, d1, d2;
      asm volatile (
!         "rep; movsl;"
!         "movl %4, %%ecx;"
!         "andl $3, %%ecx;"
!         "jz 1f;"
!         "rep; movsb;"
!         "1:"
!         : "=&c" (d0), "=&D" (d1), "=&S" (d2)
!         : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
!         : "memory");
      return dst;
  }
  #endif /* __HAVE_ARCH_MEMCPY */
--- 174,188 ----
  __memcpy(void *dst, const void *src, size_t n) {
      int d0, d1, d2;
      asm volatile (
!             "rep; movsl;"
!             "movl %4, %%ecx;"
!             "andl $3, %%ecx;"
!             "jz 1f;"
!             "rep; movsb;"
!             "1:"
!             : "=&c" (d0), "=&D" (d1), "=&S" (d2)
!             : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
!             : "memory");
      return dst;
  }
  #endif /* __HAVE_ARCH_MEMCPY */
*** Makefile	2018-04-02 22:38:25.890675642 +0800
--- Makefile	2018-04-02 22:38:25.886675400 +0800
***************
*** 1,4 ****
! PROJ	:= 5
  EMPTY	:=
  SPACE	:= $(EMPTY) $(EMPTY)
  SLASH	:= /
--- 1,4 ----
! PROJ	:= challenge
  EMPTY	:=
  SPACE	:= $(EMPTY) $(EMPTY)
  SLASH	:= /
***************
*** 8,22 ****
  #USELLVM := 1
  # try to infer the correct GCCPREFX
  ifndef GCCPREFIX
! GCCPREFIX := $(shell if i386-ucore-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
! 	then echo 'i386-ucore-elf-'; \
  	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
  	then echo ''; \
  	else echo "***" 1>&2; \
! 	echo "*** Error: Couldn't find an i386-ucore-elf version of GCC/binutils." 1>&2; \
! 	echo "*** Is the directory with i386-ucore-elf-gcc in your PATH?" 1>&2; \
! 	echo "*** If your i386-ucore-elf toolchain is installed with a command" 1>&2; \
! 	echo "*** prefix other than 'i386-ucore-elf-', set your GCCPREFIX" 1>&2; \
  	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
  	echo "*** To turn off this error, run 'gmake GCCPREFIX= ...'." 1>&2; \
  	echo "***" 1>&2; exit 1; fi)
--- 8,22 ----
  #USELLVM := 1
  # try to infer the correct GCCPREFX
  ifndef GCCPREFIX
! GCCPREFIX := $(shell if i386-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
! 	then echo 'i386-elf-'; \
  	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
  	then echo ''; \
  	else echo "***" 1>&2; \
! 	echo "*** Error: Couldn't find an i386-elf version of GCC/binutils." 1>&2; \
! 	echo "*** Is the directory with i386-elf-gcc in your PATH?" 1>&2; \
! 	echo "*** If your i386-elf toolchain is installed with a command" 1>&2; \
! 	echo "*** prefix other than 'i386-elf-', set your GCCPREFIX" 1>&2; \
  	echo "*** environment variable to that prefix and run 'make' again." 1>&2; \
  	echo "*** To turn off this error, run 'gmake GCCPREFIX= ...'." 1>&2; \
  	echo "***" 1>&2; exit 1; fi)
***************
*** 58,64 ****
  CFLAGS	+= $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
  endif
  
- GDB		:= $(GCCPREFIX)gdb
  CTYPE	:= c S
  
  LD      := $(GCCPREFIX)ld
--- 58,63 ----
  CFLAGS	+= $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
  endif
  
  CTYPE	:= c S
  
  LD      := $(GCCPREFIX)ld
***************
*** 78,86 ****
  TR		:= tr
  TOUCH	:= touch -c
  
- TAR		:= tar
- ZIP		:= gzip
- 
  OBJDIR	:= obj
  BINDIR	:= bin
  
--- 77,82 ----
  TR		:= tr
  TOUCH	:= touch -c
  
  OBJDIR	:= obj
  BINDIR	:= bin
  
***************
*** 126,142 ****
  KINCLUDE	+= kern/debug/ \
  			   kern/driver/ \
  			   kern/trap/ \
! 			   kern/mm/ \
! 			   kern/libs/ \
! 			   kern/sync/
  
  KSRCDIR		+= kern/init \
  			   kern/libs \
  			   kern/debug \
  			   kern/driver \
  			   kern/trap \
! 			   kern/mm \
! 			   kern/sync
  
  KCFLAGS		+= $(addprefix -I,$(KINCLUDE))
  
--- 122,135 ----
  KINCLUDE	+= kern/debug/ \
  			   kern/driver/ \
  			   kern/trap/ \
! 			   kern/mm/
  
  KSRCDIR		+= kern/init \
  			   kern/libs \
  			   kern/debug \
  			   kern/driver \
  			   kern/trap \
! 			   kern/mm
  
  KCFLAGS		+= $(addprefix -I,$(KINCLUDE))
  
***************
*** 157,176 ****
  
  $(call create_target,kernel)
  
- 
- # create kernel_nopage target
- kernel_nopage = $(call totarget,kernel_nopage)
- 
- $(kernel_nopage): tools/kernel_nopage.ld
- 
- $(kernel_nopage): $(KOBJS)
- 	@echo + ld $@
- 	$(V)$(LD) $(LDFLAGS) -T tools/kernel_nopage.ld -o $@ $(KOBJS)
- 	@$(OBJDUMP) -S $@ > $(call asmfile,kernel_nopage)
- 	@$(OBJDUMP) -t $@ | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $(call symfile,kernel_nopage)
- 
- $(call create_target,kernel)
- 
  # -------------------------------------------------------------------
  
  # create bootblock
--- 150,155 ----
  
  $(call create_target,kernel)
  
  # -------------------------------------------------------------------
  
  # create bootblock
***************
*** 179,187 ****
  
  bootblock = $(call totarget,bootblock)
  
! $(bootblock): $(call toobj,boot/bootasm.S) $(call toobj,$(bootfiles)) | $(call totarget,sign)
  	@echo + ld $@
! 	$(V)$(LD) $(LDFLAGS) -N -T tools/boot.ld $^ -o $(call toobj,bootblock)
  	@$(OBJDUMP) -S $(call objfile,bootblock) > $(call asmfile,bootblock)
  	@$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)
  	@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)
--- 158,166 ----
  
  bootblock = $(call totarget,bootblock)
  
! $(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign)
  	@echo + ld $@
! 	$(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock)
  	@$(OBJDUMP) -S $(call objfile,bootblock) > $(call asmfile,bootblock)
  	@$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)
  	@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)
***************
*** 199,205 ****
  # create ucore.img
  UCOREIMG	:= $(call totarget,ucore.img)
  
! $(UCOREIMG): $(kernel) $(bootblock) $(kernel_nopage)
  	$(V)dd if=/dev/zero of=$@ count=10000
  	$(V)dd if=$(bootblock) of=$@ conv=notrunc
  	$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc
--- 178,184 ----
  # create ucore.img
  UCOREIMG	:= $(call totarget,ucore.img)
  
! $(UCOREIMG): $(kernel) $(bootblock)
  	$(V)dd if=/dev/zero of=$@ count=10000
  	$(V)dd if=$(bootblock) of=$@ conv=notrunc
  	$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc
***************
*** 210,218 ****
  
  $(call finish_all)
  
! IGNORE_ALLDEPS	= gdb \
! 				  clean \
! 				  distclean \
  				  grade \
  				  touch \
  				  print-.+ \
--- 189,196 ----
  
  $(call finish_all)
  
! IGNORE_ALLDEPS	= clean \
! 				  dist-clean \
  				  grade \
  				  touch \
  				  print-.+ \
***************
*** 228,261 ****
  
  .DEFAULT_GOAL := TARGETS
  
- QEMUOPTS = -hda $(UCOREIMG)
- 
  .PHONY: qemu qemu-nox debug debug-nox
  qemu-mon: $(UCOREIMG)
! 	$(V)$(QEMU)  -no-reboot -monitor stdio $(QEMUOPTS) -serial null
  qemu: $(UCOREIMG)
! 	$(V)$(QEMU)  -no-reboot -parallel stdio $(QEMUOPTS) -serial null
! 
  qemu-nox: $(UCOREIMG)
! 	$(V)$(QEMU)  -no-reboot -serial mon:stdio $(QEMUOPTS) -nographic
! 
! TERMINAL := gnome-terminal
! 
  debug: $(UCOREIMG)
! 	$(V)$(QEMU) -S -s -parallel stdio $(QEMUOPTS) -serial null &
  	$(V)sleep 2
! 	$(V)$(TERMINAL) -e "$(GDB) -q -x tools/gdbinit"
! 
  debug-nox: $(UCOREIMG)
! 	$(V)$(QEMU) -S -s -serial mon:stdio $(QEMUOPTS) -nographic &
  	$(V)sleep 2
! 	$(V)$(TERMINAL) -e "$(GDB) -q -x tools/gdbinit"
  
  .PHONY: grade touch
  
  GRADE_GDB_IN	:= .gdb.in
  GRADE_QEMU_OUT	:= .qemu.out
! HANDIN			:= lab2-handin.tar.gz
  
  TOUCH_FILES		:= kern/trap/trap.c
  
--- 206,236 ----
  
  .DEFAULT_GOAL := TARGETS
  
  .PHONY: qemu qemu-nox debug debug-nox
  qemu-mon: $(UCOREIMG)
! 	$(V)$(QEMU)  -no-reboot -monitor stdio -hda $< -serial null
  qemu: $(UCOREIMG)
! 	$(V)$(QEMU) -no-reboot -parallel stdio -hda $< -serial null
! log: $(UCOREIMG)
! 	$(V)$(QEMU) -no-reboot -d int,cpu_reset  -D q.log -parallel stdio -hda $< -serial null
  qemu-nox: $(UCOREIMG)
! 	$(V)$(QEMU)   -no-reboot -serial mon:stdio -hda $< -nographic
! TERMINAL        :=gnome-terminal
  debug: $(UCOREIMG)
! 	$(V)$(QEMU) -S -s -parallel stdio -hda $< -serial null &
  	$(V)sleep 2
! 	$(V)$(TERMINAL) -e "gdb -q -tui -x tools/gdbinit"
! 	
  debug-nox: $(UCOREIMG)
! 	$(V)$(QEMU) -S -s -serial mon:stdio -hda $< -nographic &
  	$(V)sleep 2
! 	$(V)$(TERMINAL) -e "gdb -q -x tools/gdbinit"
  
  .PHONY: grade touch
  
  GRADE_GDB_IN	:= .gdb.in
  GRADE_QEMU_OUT	:= .qemu.out
! HANDIN			:= proj$(PROJ)-handin.tar.gz
  
  TOUCH_FILES		:= kern/trap/trap.c
  
***************
*** 271,289 ****
  print-%:
  	@echo $($(shell echo $(patsubst print-%,%,$@) | $(TR) [a-z] [A-Z]))
  
! .PHONY: clean distclean handin tags
  clean:
  	$(V)$(RM) $(GRADE_GDB_IN) $(GRADE_QEMU_OUT) cscope* tags
! 	$(V)$(RM) -r $(OBJDIR) $(BINDIR)
  
! distclean: clean
! 	$(V)$(RM) $(HANDIN)
  
- handin: distclean
- 	$(V)$(TAR) -cf - `find . -type f -o -type d | grep -v '^\.$$' | grep -v '/CVS/' \
- 					| grep -v '/\.git/' | grep -v '/\.svn/' | grep -v "$(HANDIN)"` \
- 					| $(ZIP) > $(HANDIN)
- 					
  tags:
  	@echo TAGS ALL
  	$(V)rm -f cscope.files cscope.in.out cscope.out cscope.po.out tags
--- 246,266 ----
  print-%:
  	@echo $($(shell echo $(patsubst print-%,%,$@) | $(TR) [a-z] [A-Z]))
  
! .PHONY: clean dist-clean handin packall tags
  clean:
  	$(V)$(RM) $(GRADE_GDB_IN) $(GRADE_QEMU_OUT) cscope* tags
! 	-$(RM) -r $(OBJDIR) $(BINDIR)
! 
! dist-clean: clean
! 	-$(RM) $(HANDIN)
! 
! handin: packall
! 	@echo Please visit http://learn.tsinghua.edu.cn and upload $(HANDIN). Thanks!
  
! packall: clean
! 	@$(RM) -f $(HANDIN)
! 	@tar -czf $(HANDIN) `find . -type f -o -type d | grep -v '^\.*$$' | grep -vF '$(HANDIN)'`
  
  tags:
  	@echo TAGS ALL
  	$(V)rm -f cscope.files cscope.in.out cscope.out cscope.po.out tags
*** gdbinit	2018-04-02 22:38:25.894675883 +0800
--- gdbinit	2018-04-02 22:38:25.890675642 +0800
***************
*** 1,3 ****
  file bin/kernel
  target remote :1234
  break kern_init
--- 1,4 ----
  file bin/kernel
  target remote :1234
  break kern_init
+ continue*** grade.sh	2018-04-02 22:38:25.894675883 +0800
--- grade.sh	2018-04-02 22:38:25.890675642 +0800
***************
*** 2,26 ****
  
  verbose=false
  if [ "x$1" = "x-v" ]; then
!     verbose=true
!     out=/dev/stdout
!     err=/dev/stderr
  else
!     out=/dev/null
!     err=/dev/null
  fi
  
  ## make & makeopts
  if gmake --version > /dev/null 2>&1; then
!     make=gmake;
  else
!     make=make;
  fi
  
  makeopts="--quiet --no-print-directory -j"
  
  make_print() {
!     echo `$make $makeopts print-$1`
  }
  
  ## command tools
--- 2,26 ----
  
  verbose=false
  if [ "x$1" = "x-v" ]; then
! 	verbose=true
! 	out=/dev/stdout
! 	err=/dev/stderr
  else
! 	out=/dev/null
! 	err=/dev/null
  fi
  
  ## make & makeopts
  if gmake --version > /dev/null 2>&1; then
! 	make=gmake;
  else
! 	make=make;
  fi
  
  makeopts="--quiet --no-print-directory -j"
  
  make_print() {
! 	echo `$make $makeopts print-$1`
  }
  
  ## command tools
***************
*** 35,41 ****
  sym_table='obj/kernel.sym'
  
  ## gdb & gdbopts
! gdb="$(make_print GDB)"
  gdbport='1234'
  
  gdb_in="$(make_print GRADE_GDB_IN)"
--- 35,41 ----
  sym_table='obj/kernel.sym'
  
  ## gdb & gdbopts
! gdb="$(make_print GCCPREFIX)gdb"
  gdbport='1234'
  
  gdb_in="$(make_print GRADE_GDB_IN)"
***************
*** 46,54 ****
  qemu_out="$(make_print GRADE_QEMU_OUT)"
  
  if $qemu -nographic -help | grep -q '^-gdb'; then
!     qemugdb="-gdb tcp::$gdbport"
  else
!     qemugdb="-s -p $gdbport"
  fi
  
  ## default variables
--- 46,54 ----
  qemu_out="$(make_print GRADE_QEMU_OUT)"
  
  if $qemu -nographic -help | grep -q '^-gdb'; then
! 	qemugdb="-gdb tcp::$gdbport"
  else
! 	qemugdb="-s -p $gdbport"
  fi
  
  ## default variables
***************
*** 63,310 ****
  
  ## default functions
  update_score() {
!     total=`expr $total + $part`
!     total_pos=`expr $total_pos + $part_pos`
!     part=0
!     part_pos=0
  }
  
  get_time() {
!     echo `$date +%s.%N 2> /dev/null`
  }
  
  show_part() {
!     echo "Part $1 Score: $part/$part_pos"
!     echo
!     update_score
  }
  
  show_final() {
!     update_score
!     echo "Total Score: $total/$total_pos"
!     if [ $total -lt $total_pos ]; then
!         exit 1
!     fi
  }
  
  show_time() {
!     t1=$(get_time)
!     time=`echo "scale=1; ($t1-$t0)/1" | $sed 's/.N/.0/g' | $bc 2> /dev/null`
!     echo "(${time}s)"
  }
  
  show_build_tag() {
!     echo "$1:" | $awk '{printf "%-24s ", $0}'
  }
  
  show_check_tag() {
!     echo "$1:" | $awk '{printf "  -%-40s  ", $0}'
  }
  
  show_msg() {
!     echo $1
!     shift
!     if [ $# -gt 0 ]; then
!         echo -e "$@" | awk '{printf "   %s\n", $0}'
!         echo
!     fi
  }
  
  pass() {
!     show_msg OK "$@"
!     part=`expr $part + $pts`
!     part_pos=`expr $part_pos + $pts`
  }
  
  fail() {
!     show_msg WRONG "$@"
!     part_pos=`expr $part_pos + $pts`
  }
  
  run_qemu() {
!     # Run qemu with serial output redirected to $qemu_out. If $brkfun is non-empty,
!     # wait until $brkfun is reached or $timeout expires, then kill QEMU
!     qemuextra=
!     if [ "$brkfun" ]; then
!         qemuextra="-S $qemugdb"
!     fi
! 
!     if [ -z "$timeout" ] || [ $timeout -le 0 ]; then
!         timeout=$default_timeout;
!     fi
! 
!     t0=$(get_time)
!     (
!         ulimit -t $timeout
!         exec $qemu -nographic $qemuopts -serial file:$qemu_out -monitor null -no-reboot $qemuextra
!     ) > $out 2> $err &
!     pid=$!
! 
!     # wait for QEMU to start
!     sleep 1
! 
!     if [ -n "$brkfun" ]; then
!         # find the address of the kernel $brkfun function
!         brkaddr=`$grep " $brkfun\$" $sym_table | $sed -e's/ .*$//g'`
!         brkaddr_phys=`echo $brkaddr | sed "s/^c0/00/g"`
!         (
!             echo "target remote localhost:$gdbport"
!             echo "break *0x$brkaddr"
!             if [ "$brkaddr" != "$brkaddr_phys" ]; then
!                 echo "break *0x$brkaddr_phys"
!             fi
!             echo "continue"
!         ) > $gdb_in
! 
!         $gdb -batch -nx -x $gdb_in > /dev/null 2>&1
! 
!         # make sure that QEMU is dead
!         # on OS X, exiting gdb doesn't always exit qemu
!         kill $pid > /dev/null 2>&1
!     fi
  }
  
  build_run() {
!     # usage: build_run <tag> <args>
!     show_build_tag "$1"
!     shift
! 
!     if $verbose; then
!         echo "$make $@ ..."
!     fi
!     $make $makeopts $@ 'DEFS+=-DDEBUG_GRADE' > $out 2> $err
! 
!     if [ $? -ne 0 ]; then
!         echo $make $@ failed
!         exit 1
!     fi
  
!     # now run qemu and save the output
!     run_qemu
  
!     show_time
  
!     cp $qemu_out .`echo $tag | tr '[:upper:]' '[:lower:]' | sed 's/ /_/g'`.log
  }
  
  check_result() {
!     # usage: check_result <tag> <check> <check args...>
!     show_check_tag "$1"
!     shift
! 
!     # give qemu some time to run (for asynchronous mode)
!     if [ ! -s $qemu_out ]; then
!         sleep 4
!     fi
! 
!     if [ ! -s $qemu_out ]; then
!         fail > /dev/null
!         echo 'no $qemu_out'
!     else
!         check=$1
!         shift
!         $check "$@"
!     fi
  }
  
  check_regexps() {
!     okay=yes
!     not=0
!     reg=0
!     error=
!     for i do
!         if [ "x$i" = "x!" ]; then
!             not=1
!         elif [ "x$i" = "x-" ]; then
!             reg=1
!         else
!             if [ $reg -ne 0 ]; then
!                 $grep '-E' "^$i\$" $qemu_out > /dev/null
!             else
!                 $grep '-F' "$i" $qemu_out > /dev/null
!             fi
!             found=$(($? == 0))
!             if [ $found -eq $not ]; then
!                 if [ $found -eq 0 ]; then
!                     msg="!! error: missing '$i'"
!                 else
!                     msg="!! error: got unexpected line '$i'"
!                 fi
!                 okay=no
!                 if [ -z "$error" ]; then
!                     error="$msg"
!                 else
!                     error="$error\n$msg"
!                 fi
!             fi
!             not=0
!             reg=0
!         fi
!     done
!     if [ "$okay" = "yes" ]; then
!         pass
!     else
!         fail "$error"
!         if $verbose; then
!             exit 1
!         fi
!     fi
  }
  
  run_test() {
!     # usage: run_test [-tag <tag>] [-Ddef...] [-check <check>] checkargs ...
!     tag=
!     check=check_regexps
!     while true; do
!         select=
!         case $1 in
!             -tag)
!                 select=`expr substr $1 2 ${#1}`
!                 eval $select='$2'
!                 ;;
!         esac
!         if [ -z "$select" ]; then
!             break
!         fi
!         shift
!         shift
!     done
!     defs=
!     while expr "x$1" : "x-D.*" > /dev/null; do
!         defs="DEFS+='$1' $defs"
!         shift
!     done
!     if [ "x$1" = "x-check" ]; then
!         check=$2
!         shift
!         shift
!     fi
  
!     $make $makeopts touch > /dev/null 2>&1
!     build_run "$tag" "$defs"
  
!     check_result 'check result' "$check" "$@"
  }
  
  quick_run() {
!     # usage: quick_run <tag> [-Ddef...]
!     tag="$1"
!     shift
!     defs=
!     while expr "x$1" : "x-D.*" > /dev/null; do
!         defs="DEFS+='$1' $defs"
!         shift
!     done
  
!     $make $makeopts touch > /dev/null 2>&1
!     build_run "$tag" "$defs"
  }
  
  quick_check() {
!     # usage: quick_check <tag> checkargs ...
!     tag="$1"
!     shift
!     check_result "$tag" check_regexps "$@"
  }
  
  ## kernel image
--- 63,310 ----
  
  ## default functions
  update_score() {
! 	total=`expr $total + $part`
! 	total_pos=`expr $total_pos + $part_pos`
! 	part=0
! 	part_pos=0
  }
  
  get_time() {
! 	echo `$date +%s.%N 2> /dev/null`
  }
  
  show_part() {
! 	echo "Part $1 Score: $part/$part_pos"
! 	echo
! 	update_score
  }
  
  show_final() {
! 	update_score
! 	echo "Total Score: $total/$total_pos"
! 	if [ $total -lt $total_pos ]; then
! 		exit 1
! 	fi
  }
  
  show_time() {
! 	t1=$(get_time)
! 	time=`echo "scale=1; ($t1-$t0)/1" | $sed 's/.N/.0/g' | $bc 2> /dev/null`
! 	echo "(${time}s)"
  }
  
  show_build_tag() {
! 	echo "$1:" | $awk '{printf "%-24s ", $0}'
  }
  
  show_check_tag() {
! 	echo "$1:" | $awk '{printf "  -%-40s  ", $0}'
  }
  
  show_msg() {
! 	echo $1
! 	shift
! 	if [ $# -gt 0 ]; then
! 		echo -e "$@" | awk '{printf "   %s\n", $0}'
! 		echo
! 	fi
  }
  
  pass() {
! 	show_msg OK "$@"
! 	part=`expr $part + $pts`
! 	part_pos=`expr $part_pos + $pts`
  }
  
  fail() {
! 	show_msg WRONG "$@"
! 	part_pos=`expr $part_pos + $pts`
  }
  
  run_qemu() {
! 	# Run qemu with serial output redirected to $qemu_out. If $brkfun is non-empty,
! 	# wait until $brkfun is reached or $timeout expires, then kill QEMU
! 	qemuextra=
! 	if [ "$brkfun" ]; then
! 		qemuextra="-S $qemugdb"
! 	fi
! 
! 	if [ -z "$timeout" ] || [ $timeout -le 0 ]; then
! 		timeout=$default_timeout;
! 	fi
! 
! 	t0=$(get_time)
! 	(
! 		ulimit -t $timeout
! 		exec $qemu -nographic $qemuopts -serial file:$qemu_out -monitor null -no-reboot $qemuextra
! 	) > $out 2> $err &
! 	pid=$!
! 
! 	# wait for QEMU to start
! 	sleep 1
! 
! 	if [ -n "$brkfun" ]; then
! 		# find the address of the kernel $brkfun function
! 		brkaddr=`$grep " $brkfun\$" $sym_table | $sed -e's/ .*$//g'`
! 		brkaddr_phys=`echo $brkaddr | sed "s/^c0/00/g"`
! 		(
! 			echo "target remote localhost:$gdbport"
! 			echo "break *0x$brkaddr"
! 			if [ "$brkaddr" != "$brkaddr_phys" ]; then
! 			    echo "break *0x$brkaddr_phys"
! 			fi
! 			echo "continue"
! 		) > $gdb_in
! 
! 		$gdb -batch -nx -x $gdb_in > /dev/null 2>&1
! 
! 		# make sure that QEMU is dead
! 		# on OS X, exiting gdb doesn't always exit qemu
! 		kill $pid > /dev/null 2>&1
! 	fi
  }
  
  build_run() {
! 	# usage: build_run <tag> <args>
! 	show_build_tag "$1"
! 	shift
! 
! 	if $verbose; then
! 		echo "$make $@ ..."
! 	fi
! 	$make $makeopts $@ 'DEFS+=-DDEBUG_GRADE' > $out 2> $err
! 
! 	if [ $? -ne 0 ]; then
! 		echo $make $@ failed
! 		exit 1
! 	fi
  
! 	# now run qemu and save the output
! 	run_qemu
  
! 	show_time
  
! 	cp $qemu_out .`echo $tag | tr '[:upper:]' '[:lower:]' | sed 's/ /_/g'`.log
  }
  
  check_result() {
! 	# usage: check_result <tag> <check> <check args...>
! 	show_check_tag "$1"
! 	shift
! 
! 	# give qemu some time to run (for asynchronous mode)
! 	if [ ! -s $qemu_out ]; then
! 		sleep 4
! 	fi
! 
! 	if [ ! -s $qemu_out ]; then
! 		fail > /dev/null
! 		echo 'no $qemu_out'
! 	else
! 		check=$1
! 		shift
! 		$check "$@"
! 	fi
  }
  
  check_regexps() {
! 	okay=yes
! 	not=0
! 	reg=0
! 	error=
! 	for i do
! 		if [ "x$i" = "x!" ]; then
! 			not=1
! 		elif [ "x$i" = "x-" ]; then
! 			reg=1
! 		else
! 			if [ $reg -ne 0 ]; then
! 				$grep '-E' "^$i\$" $qemu_out > /dev/null
! 			else
! 				$grep '-F' "$i" $qemu_out > /dev/null
! 			fi
! 			found=$(($? == 0))
! 			if [ $found -eq $not ]; then
! 				if [ $found -eq 0 ]; then
! 					msg="!! error: missing '$i'"
! 				else
! 					msg="!! error: got unexpected line '$i'"
! 				fi
! 				okay=no
! 				if [ -z "$error" ]; then
! 					error="$msg"
! 				else
! 					error="$error\n$msg"
! 				fi
! 			fi
! 			not=0
! 			reg=0
! 		fi
! 	done
! 	if [ "$okay" = "yes" ]; then
! 		pass
! 	else
! 		fail "$error"
! 		if $verbose; then
! 			exit 1
! 		fi
! 	fi
  }
  
  run_test() {
! 	# usage: run_test [-tag <tag>] [-Ddef...] [-check <check>] checkargs ...
! 	tag=
! 	check=check_regexps
! 	while true; do
! 		select=
! 		case $1 in
! 			-tag)
! 				select=`expr substr $1 2 ${#1}`
! 				eval $select='$2'
! 				;;
! 		esac
! 		if [ -z "$select" ]; then
! 			break
! 		fi
! 		shift
! 		shift
! 	done
! 	defs=
! 	while expr "x$1" : "x-D.*" > /dev/null; do
! 		defs="DEFS+='$1' $defs"
! 		shift
! 	done
! 	if [ "x$1" = "x-check" ]; then
! 		check=$2
! 		shift
! 		shift
! 	fi
  
! 	$make $makeopts touch > /dev/null 2>&1
! 	build_run "$tag" "$defs"
  
! 	check_result 'check result' "$check" "$@"
  }
  
  quick_run() {
! 	# usage: quick_run <tag> [-Ddef...]
! 	tag="$1"
! 	shift
! 	defs=
! 	while expr "x$1" : "x-D.*" > /dev/null; do
! 		defs="DEFS+='$1' $defs"
! 		shift
! 	done
  
! 	$make $makeopts touch > /dev/null 2>&1
! 	build_run "$tag" "$defs"
  }
  
  quick_check() {
! 	# usage: quick_check <tag> checkargs ...
! 	tag="$1"
! 	shift
! 	check_result "$tag" check_regexps "$@"
  }
  
  ## kernel image
***************
*** 318,345 ****
  
  ## check now!!
  
! quick_run 'Check PMM'
! 
! pts=20
! quick_check 'check pmm'                                         \
!     'memory management: default_pmm_manager'                     \
!     'check_alloc_page() succeeded!'                             \
!     'check_pgdir() succeeded!'                                  \
!     'check_boot_pgdir() succeeded!'
! 
! pts=20
! quick_check 'check page table'                                  \
!     'PDE(0e0) c0000000-f8000000 38000000 urw'                   \
!     '  |-- PTE(38000) c0000000-f8000000 38000000 -rw'           \
!     'PDE(001) fac00000-fb000000 00400000 -rw'                   \
!     '  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw'           \
!     '  |-- PTE(00001) fafeb000-fafec000 00001000 -rw'
  
  pts=10
! quick_check 'check ticks'                                       \
!     '++ setup timer interrupts'                                 \
!     '100 ticks'                                                 \
!     'End of Test.'
  
  ## print final-score
  show_final
--- 318,353 ----
  
  ## check now!!
  
! quick_run 'Check Output'
  
  pts=10
! quick_check 'check ring 0'										\
! 	'0: @ring 0'												\
! 	'0:  cs = 8'												\
! 	'0:  ds = 10'												\
! 	'0:  es = 10'												\
! 	'0:  ss = 10'
! 
! quick_check 'check switch to ring 3'							\
! 	'+++ switch to  user  mode +++'								\
! 	'1: @ring 3'												\
! 	'1:  cs = 1b'												\
! 	'1:  ds = 23'												\
! 	'1:  es = 23'												\
! 	'1:  ss = 23'
! 
! quick_check 'check switch to ring 0'							\
! 	'+++ switch to kernel mode +++'								\
! 	'2: @ring 0'												\
! 	'2:  cs = 8'												\
! 	'2:  ds = 10'												\
! 	'2:  es = 10'												\
! 	'2:  ss = 10'
! 
! quick_check 'check ticks'										\
! 	'++ setup timer interrupts'									\
! 	'100 ticks'													\
! 	'End of Test.'
  
  ## print final-score
  show_final
*** kernel.ld	2018-04-02 22:38:25.894675883 +0800
--- kernel.ld	2018-04-02 22:38:25.890675642 +0800
***************
*** 1,63 ****
! /* Simple linker script for the ucore kernel.
     See the GNU ld 'info' manual ("info ld") to learn the syntax. */
  
  OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
  OUTPUT_ARCH(i386)
! ENTRY(kern_entry)
  
  SECTIONS {
!     /* Load the kernel at this address: "." means the current address */
!     . = 0xC0100000;
  
!     .text : {
!         *(.text .stub .text.* .gnu.linkonce.t.*)
!     }
! 
!     PROVIDE(etext = .); /* Define the 'etext' symbol to this value */
! 
!     .rodata : {
!         *(.rodata .rodata.* .gnu.linkonce.r.*)
!     }
! 
!     /* Include debugging information in kernel memory */
!     .stab : {
!         PROVIDE(__STAB_BEGIN__ = .);
!         *(.stab);
!         PROVIDE(__STAB_END__ = .);
!         BYTE(0)     /* Force the linker to allocate space
!                    for this section */
!     }
! 
!     .stabstr : {
!         PROVIDE(__STABSTR_BEGIN__ = .);
!         *(.stabstr);
!         PROVIDE(__STABSTR_END__ = .);
!         BYTE(0)     /* Force the linker to allocate space
!                    for this section */
!     }
! 
!     /* Adjust the address for the data segment to the next page */
!     . = ALIGN(0x1000);
! 
!     /* The data segment */
!     .data : {
!         *(.data)
!     }
! 
!     . = ALIGN(0x1000);
!     .data.pgdir : {
!         *(.data.pgdir)
!     }
! 
!     PROVIDE(edata = .);
! 
!     .bss : {
!         *(.bss)
!     }
! 
!     PROVIDE(end = .);
! 
!     /DISCARD/ : {
!         *(.eh_frame .note.GNU-stack)
!     }
  }
--- 1,58 ----
! /* Simple linker script for the JOS kernel.
     See the GNU ld 'info' manual ("info ld") to learn the syntax. */
  
  OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
  OUTPUT_ARCH(i386)
! ENTRY(kern_init)
  
  SECTIONS {
! 	/* Load the kernel at this address: "." means the current address */
! 	. = 0x100000;
  
! 	.text : {
! 		*(.text .stub .text.* .gnu.linkonce.t.*)
! 	}
! 
! 	PROVIDE(etext = .);	/* Define the 'etext' symbol to this value */
! 
! 	.rodata : {
! 		*(.rodata .rodata.* .gnu.linkonce.r.*)
! 	}
! 
! 	/* Include debugging information in kernel memory */
! 	.stab : {
! 		PROVIDE(__STAB_BEGIN__ = .);
! 		*(.stab);
! 		PROVIDE(__STAB_END__ = .);
! 		BYTE(0)		/* Force the linker to allocate space
! 				   for this section */
! 	}
! 
! 	.stabstr : {
! 		PROVIDE(__STABSTR_BEGIN__ = .);
! 		*(.stabstr);
! 		PROVIDE(__STABSTR_END__ = .);
! 		BYTE(0)		/* Force the linker to allocate space
! 				   for this section */
! 	}
! 
! 	/* Adjust the address for the data segment to the next page */
! 	. = ALIGN(0x1000);
! 
! 	/* The data segment */
! 	.data : {
! 		*(.data)
! 	}
! 
! 	PROVIDE(edata = .);
! 
! 	.bss : {
! 		*(.bss)
! 	}
! 
! 	PROVIDE(end = .);
! 
! 	/DISCARD/ : {
! 		*(.eh_frame .note.GNU-stack)
! 	}
  }
